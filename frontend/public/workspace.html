<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workspace - SmartWrite</title>
    <link rel="stylesheet" href="/assets/styles/style.css">
    <link rel="stylesheet" href="/assets/styles/workspace.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">
    <!-- Marked library for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Prism for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
    <!-- CodeMirror for markdown editing -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"></script>
    
    <!-- Direct fallback for ensuring markdown section is visible and accessible -->
    <script>
        // Direct fallback to ensure markdown section is ready
        window.ensureMarkdownSectionVisible = function() {
            console.log('[Markdown] Ensuring markdown section is visible');
            
            // Get the elements
            let markdownSection = document.querySelector('.markdown-section');
            const pdfContainer = document.getElementById('pdfPagesContainer');
            const pdfViewer = document.getElementById('pdfViewer');
            
            // If the markdown section doesn't exist, create it
            if (!markdownSection) {
                console.log('[Markdown] Markdown section not found, creating it');
                
                // Check if we have a PDF viewer to append to
                if (!pdfViewer) {
                    console.error('[Markdown] PDF viewer not found, cannot create markdown section');
                    return {
                        markdownSection: null,
                        markdownContainer: null,
                        markdownEditor: null,
                        markdownPreview: null
                    };
                }
                
                // Create the markdown section with inline styles
                markdownSection = document.createElement('div');
                markdownSection.className = 'markdown-section';
                markdownSection.style.display = 'flex';
                markdownSection.style.flexDirection = 'column';
                markdownSection.style.position = 'absolute';
                markdownSection.style.top = '0';
                markdownSection.style.left = '0';
                markdownSection.style.right = '0';
                markdownSection.style.bottom = '0';
                markdownSection.style.backgroundColor = 'var(--bg-primary, white)';
                markdownSection.style.zIndex = '10';
                markdownSection.style.height = '100%';
                markdownSection.style.width = '100%';
                markdownSection.style.overflow = 'hidden';
                
                // Create controls with inline styles
                const markdownControls = document.createElement('div');
                markdownControls.className = 'markdown-controls';
                markdownControls.style.display = 'flex';
                markdownControls.style.alignItems = 'center';
                markdownControls.style.gap = '15px';
                markdownControls.style.padding = '6px';
                markdownControls.style.backgroundColor = 'var(--bg-secondary, #f5f5f5)';
                markdownControls.style.borderBottom = '1px solid var(--border-color, #ddd)';
                markdownControls.style.height = '32px';
                markdownControls.style.flexShrink = '0';
                markdownControls.style.zIndex = '1';
                markdownControls.innerHTML = `
                    <div class="markdown-title" id="markdownTitle" style="font-size:14px;font-weight:500;color:var(--text-primary,#333);flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">Markdown Viewer</div>
                    <div class="markdown-view-controls" style="display:flex;gap:10px;margin-left:auto;">
                        <button class="view-mode-btn active" data-mode="edit" style="border:none;background:none;color:var(--text-secondary,#666);cursor:pointer;padding:4px 8px;border-radius:4px;font-size:12px;background-color:var(--accent-primary,#007bff);color:white;">Edit</button>
                        <button class="view-mode-btn" data-mode="split" style="border:none;background:none;color:var(--text-secondary,#666);cursor:pointer;padding:4px 8px;border-radius:4px;font-size:12px;">Split</button>
                        <button class="view-mode-btn" data-mode="preview" style="border:none;background:none;color:var(--text-secondary,#666);cursor:pointer;padding:4px 8px;border-radius:4px;font-size:12px;">Preview</button>
                    </div>
                    <div class="markdown-editing-indicator" style="display:none;font-size:12px;color:var(--text-secondary,#666);margin-left:auto;align-items:center;gap:5px;">
                        <i class="fas fa-pen"></i> Editing
                    </div>
                `;
                markdownSection.appendChild(markdownControls);
                
                // Create the viewer container with inline styles
                const markdownViewer = document.createElement('div');
                markdownViewer.className = 'markdown-viewer';
                markdownViewer.style.flex = '1';
                markdownViewer.style.overflowY = 'auto';
                markdownViewer.style.padding = '16px';
                markdownViewer.style.backgroundColor = 'var(--bg-primary, white)';
                markdownViewer.style.display = 'flex';
                markdownViewer.style.flexDirection = 'column';
                markdownSection.appendChild(markdownViewer);
                
                // Create the main container with inline styles
                const markdownContainer = document.createElement('div');
                markdownContainer.id = 'markdownContainer';
                markdownContainer.className = 'markdown-container';
                markdownContainer.style.maxWidth = '800px';
                markdownContainer.style.margin = '0 auto';
                markdownContainer.style.lineHeight = '1.6';
                markdownContainer.style.fontSize = '16px';
                markdownContainer.style.color = 'var(--text-primary, #333)';
                markdownContainer.style.width = '100%';
                markdownContainer.style.height = '100%';
                markdownViewer.appendChild(markdownContainer);
                
                // Create the split view container with inline styles
                const splitView = document.createElement('div');
                splitView.className = 'markdown-split-view';
                splitView.style.display = 'flex';
                splitView.style.height = '100%';
                splitView.style.gap = '20px';
                markdownContainer.appendChild(splitView);
                
                // Create editor with inline styles
                const markdownEditor = document.createElement('div');
                markdownEditor.id = 'markdownEditor';
                markdownEditor.className = 'markdown-editor';
                markdownEditor.style.flex = '1';
                markdownEditor.style.minHeight = '300px';
                splitView.appendChild(markdownEditor);
                
                // Create preview with inline styles
                const markdownPreview = document.createElement('div');
                markdownPreview.id = 'markdownPreview';
                markdownPreview.className = 'markdown-preview';
                markdownPreview.style.flex = '1';
                markdownPreview.style.overflowY = 'auto';
                markdownPreview.style.padding = '0 10px';
                markdownPreview.style.borderLeft = '1px solid var(--border-color, #ddd)';
                splitView.appendChild(markdownPreview);
                
                // Add the markdown section to the PDF viewer
                pdfViewer.appendChild(markdownSection);
                
                console.log('[Markdown] Created new markdown section');
                
                // Add event listeners to the view mode buttons
                markdownSection.querySelectorAll('.view-mode-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const mode = this.getAttribute('data-mode');
                        if (typeof setMarkdownViewMode === 'function') {
                            setMarkdownViewMode(mode);
                        }
                    });
                });
            }
            
            // Set markdown section to display flex
            markdownSection.style.display = 'flex';
            console.log('[Markdown] Section display set to flex');
            
            // Hide PDF container if it exists
            if (pdfContainer) {
                pdfContainer.style.display = 'none';
            }
            
            // Get the container elements
            let markdownContainer = document.getElementById('markdownContainer');
            let markdownEditor = document.getElementById('markdownEditor');
            let markdownPreview = document.getElementById('markdownPreview');
            
            // Check if we have our container elements
            if (!markdownContainer || !markdownEditor || !markdownPreview) {
                console.error('[Markdown] One or more markdown containers missing', {
                    markdownContainer: !!markdownContainer,
                    markdownEditor: !!markdownEditor,
                    markdownPreview: !!markdownPreview
                });
                
                // Try to find the existing containers by another method
                const markdownViewer = markdownSection.querySelector('.markdown-viewer');
                
                if (!markdownViewer) {
                    console.log('[Markdown] Creating markdown viewer');
                    const viewer = document.createElement('div');
                    viewer.className = 'markdown-viewer';
                    viewer.style.flex = '1';
                    viewer.style.overflowY = 'auto';
                    viewer.style.padding = '16px';
                    viewer.style.backgroundColor = 'var(--bg-primary, white)';
                    viewer.style.display = 'flex';
                    viewer.style.flexDirection = 'column';
                    viewer.style.width = '100%';
                    viewer.style.height = 'calc(100% - 32px)'; // Subtract header height
                    markdownSection.appendChild(viewer);
                    
                    // Create container
                    markdownContainer = document.createElement('div');
                    markdownContainer.id = 'markdownContainer';
                    markdownContainer.className = 'markdown-container';
                    markdownContainer.style.maxWidth = '900px';
                    markdownContainer.style.margin = '0 auto';
                    markdownContainer.style.lineHeight = '1.6';
                    markdownContainer.style.fontSize = '16px';
                    markdownContainer.style.color = 'var(--text-primary, #333)';
                    markdownContainer.style.width = '100%';
                    markdownContainer.style.height = '100%';
                    markdownContainer.style.position = 'relative';
                    markdownContainer.style.display = 'flex';
                    markdownContainer.style.flexDirection = 'column';
                    viewer.appendChild(markdownContainer);
                    
                    // Create split view
                    const splitView = document.createElement('div');
                    splitView.className = 'markdown-split-view';
                    splitView.style.display = 'flex';
                    splitView.style.height = '100%';
                    splitView.style.gap = '20px';
                    splitView.style.width = '100%';
                    splitView.style.overflow = 'hidden';
                    splitView.style.position = 'relative';
                    markdownContainer.appendChild(splitView);
                    
                    // Create editor
                    markdownEditor = document.createElement('div');
                    markdownEditor.id = 'markdownEditor';
                    markdownEditor.className = 'markdown-editor';
                    markdownEditor.style.flex = '1';
                    markdownEditor.style.minHeight = '300px';
                    markdownEditor.style.overflow = 'auto';
                    markdownEditor.style.border = '1px solid var(--border-color, #ddd)';
                    markdownEditor.style.borderRadius = '4px';
                    markdownEditor.style.backgroundColor = 'var(--bg-primary, white)';
                    markdownEditor.style.position = 'relative';
                    splitView.appendChild(markdownEditor);
                    
                    // Create preview
                    markdownPreview = document.createElement('div');
                    markdownPreview.id = 'markdownPreview';
                    markdownPreview.className = 'markdown-preview';
                    markdownPreview.style.flex = '1';
                    markdownPreview.style.overflowY = 'auto';
                    markdownPreview.style.padding = '0 10px';
                    markdownPreview.style.borderLeft = '1px solid var(--border-color, #ddd)';
                    markdownPreview.style.backgroundColor = 'var(--bg-primary, white)';
                    markdownPreview.style.position = 'relative';
                    splitView.appendChild(markdownPreview);
                    
                    console.log('[Markdown] Created markdown containers');
                } else {
                    if (!markdownContainer) {
                        // Create or find container
                        markdownContainer = markdownViewer.querySelector('#markdownContainer');
                        if (!markdownContainer) {
                            console.log('[Markdown] Creating markdown container');
                            markdownContainer = document.createElement('div');
                            markdownContainer.id = 'markdownContainer';
                            markdownContainer.className = 'markdown-container';
                            markdownContainer.style.maxWidth = '800px';
                            markdownContainer.style.margin = '0 auto';
                            markdownContainer.style.lineHeight = '1.6';
                            markdownContainer.style.fontSize = '16px';
                            markdownContainer.style.color = 'var(--text-primary, #333)';
                            markdownContainer.style.width = '100%';
                            markdownContainer.style.height = '100%';
                            markdownViewer.appendChild(markdownContainer);
                        }
                    }
                    
                    // Create split view if needed
                    let splitView = markdownContainer.querySelector('.markdown-split-view');
                    if (!splitView) {
                        console.log('[Markdown] Creating split view');
                        splitView = document.createElement('div');
                        splitView.className = 'markdown-split-view';
                        splitView.style.display = 'flex';
                        splitView.style.height = '100%';
                        splitView.style.gap = '20px';
                        markdownContainer.appendChild(splitView);
                    }
                    
                    // Create editor if needed
                    if (!markdownEditor) {
                        console.log('[Markdown] Creating markdown editor');
                        markdownEditor = document.createElement('div');
                        markdownEditor.id = 'markdownEditor';
                        markdownEditor.className = 'markdown-editor';
                        markdownEditor.style.flex = '1';
                        markdownEditor.style.minHeight = '300px';
                        markdownEditor.style.overflow = 'auto';
                        markdownEditor.style.border = '1px solid var(--border-color, #ddd)';
                        markdownEditor.style.borderRadius = '4px';
                        markdownEditor.style.backgroundColor = 'var(--bg-primary, white)';
                        markdownEditor.style.position = 'relative';
                        splitView.appendChild(markdownEditor);
                    }
                    
                    // Create preview if needed
                    if (!markdownPreview) {
                        console.log('[Markdown] Creating markdown preview');
                        markdownPreview = document.createElement('div');
                        markdownPreview.id = 'markdownPreview';
                        markdownPreview.className = 'markdown-preview';
                        markdownPreview.style.flex = '1';
                        markdownPreview.style.overflowY = 'auto';
                        markdownPreview.style.padding = '0 10px';
                        markdownPreview.style.borderLeft = '1px solid var(--border-color, #ddd)';
                        markdownPreview.style.backgroundColor = 'var(--bg-primary, white)';
                        markdownPreview.style.position = 'relative';
                        splitView.appendChild(markdownPreview);
                    }
                }
                
                // Check if we now have our elements
                markdownContainer = document.getElementById('markdownContainer');
                markdownEditor = document.getElementById('markdownEditor');
                markdownPreview = document.getElementById('markdownPreview');
                
                console.log('[Markdown] After creation:', {
                    markdownContainer: !!markdownContainer,
                    markdownEditor: !!markdownEditor,
                    markdownPreview: !!markdownPreview
                });
            }
            
            return {
                markdownSection,
                markdownContainer,
                markdownEditor,
                markdownPreview
            };
        };
    </script>
    <script>
        // Set up PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            console.log('[PDF.js] Worker initialized');
        } else {
            console.error('[PDF.js] PDF.js library not loaded');
        }
        
        // Check markdown libraries on page load
        window.addEventListener('DOMContentLoaded', function() {
            console.log('[Markdown] Checking libraries on page load');
            if (typeof marked === 'undefined') {
                console.error('[Markdown] Marked library not loaded');
            }
            if (typeof CodeMirror === 'undefined') {
                console.error('[Markdown] CodeMirror not loaded');
            }
            if (typeof Prism === 'undefined') {
                console.error('[Markdown] Prism not loaded');
            }
            
            // Ensure the markdown handler function is set globally
            // This addresses the error: "[FileTree] Markdown handler function not available"
            if (typeof handleMarkdownFileSelection === 'function') {
                window.handleMarkdownFileSelection = handleMarkdownFileSelection;
                console.log('[Markdown] Handler function set globally');
            } else {
                console.error('[Markdown] Handler function not available to set globally');
            }
        });
    </script>
    
    <!-- Text layer fix -->
    <link rel="stylesheet" href="/frontend/public/text-layer-fix.css">
    <script src="/frontend/public/text-layer-fix.js"></script>
    <style>
        /* Ensure modal is visible when active */
        .modal-overlay.active {
            display: flex !important;
        }
        
        /* PDF Viewer Styles */
        .pdf-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            left: 0;
        }

        .pdf-viewer {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: auto;
            min-height: 0;
            width: 100%;
            margin: 0;
            padding: 0;
            left: 0;
            background-color: var(--bg-primary);
        }

        .pdf-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 48px;
            width: 100%;
            position: relative;
            background-color: var(--bg-primary);
            transform-origin: center top;
            margin: 0;
            box-sizing: border-box;
            left: 0;
        }
        
        .pdf-pages-container {
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
            overflow: visible;
        }
        
        .pdf-page {
            position: relative;
            margin: 8px auto;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            background-color: var(--pdf-bg);
            border-radius: 4px;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
            width: fit-content;
        }
        
        .pdf-page-wrapper {
            position: relative;
            display: block;
            overflow: visible;
            transform-origin: 0% 0%;
        }
        
        .pdf-page-wrapper canvas {
            position: relative;
            z-index: 1;
            display: block;
        }
        
        .page-number {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .page-number:hover {
            transform: scale(1.05);
            background-color: var(--accent-primary);
            color: white;
        }
        
        .page-number:active {
            transform: scale(0.95);
        }
        
        .pdf-error {
            padding: 20px;
            text-align: center;
            border-radius: 5px;
            margin: 20px;
            background-color: rgba(211, 47, 47, 0.1);
            color: #d32f2f;
            border-left: 4px solid #d32f2f;
        }
        
        #pdfPagesContainer {
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
        }

        /* Text Layer Styles */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.25;
            line-height: 1.0;
            text-align: initial;
            pointer-events: auto;
            user-select: text;
            z-index: 2;
            /* No transform on the container itself */
            transform: none !important;
        }

        /* Style for all text elements in the textLayer */
        .textLayer > span,
        .textLayer > div {
            color: transparent;
            position: absolute !important;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            /* Use default transform to allow PDF.js to position correctly */
            margin: 0;
            padding: 0;
            /* Improve text selection behavior */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            /* Prevent overlapping selection ranges */
            box-sizing: content-box;
        }
        
        /* Special class for spans that are part of multi-span selection */
        .textLayer > span[data-has-next-span="true"],
        .textLayer > div[data-has-next-span="true"] {
            /* Slightly adjust the right side to improve selection behavior */
            padding-right: 0.1px;
        }
        
        .textLayer > span[data-has-prev-span="true"],
        .textLayer > div[data-has-prev-span="true"] {
            /* Slightly adjust the left side to improve selection behavior */
            padding-left: 0.1px;
        }
        
        /* When selected, make text more visible with improved alignment */
        .textLayer ::selection {
            background: rgba(0, 100, 255, 0.4);
            mix-blend-mode: multiply;
            transform-origin: 0% 0%;
            transform: scaleX(1.0);
            /* Improve selection appearance */
            border-radius: 1px;
            box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.1);
        }
        
        .textLayer ::-moz-selection {
            background: rgba(0, 100, 255, 0.4);
            mix-blend-mode: multiply;
            transform-origin: 0% 0%;
            transform: scaleX(1.0);
            /* Improve selection appearance */
            border-radius: 1px;
            box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.1);
        }

        /* For highlighting when search is active */
        .textLayer .highlight {
            background-color: rgba(180, 0, 170, 0.4);
            border-radius: 1px;
            box-shadow: 0px 0px 1px rgba(0, 0, 0, 0.5);
        }

        .textLayer .highlight.selected {
            background-color: rgba(0, 100, 0, 0.4);
        }
        
        /* Ensure the PDF page wrapper positions content properly */
        .pdf-page-wrapper {
            position: relative;
            display: block;
            overflow: visible;
            transform-origin: 0% 0%;
        }
        
        .pdf-page-wrapper canvas {
            position: relative;
            z-index: 1;
            display: block;
        }
        
        .search-highlight {
            position: absolute;
            background-color: rgba(255, 255, 0, 0.3);
            border: 1px solid rgba(255, 255, 0, 0.5);
            pointer-events: none;
            z-index: 3;
            mix-blend-mode: multiply;
            border-radius: 2px;
        }

        .search-highlight:hover {
            background-color: rgba(255, 255, 0, 0.5);
        }

        .search-highlight.current {
            background-color: rgba(76, 175, 80, 0.5);
            border-color: rgba(76, 175, 80, 0.8);
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        /* Loading and Error States */
        .pdf-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        /* PDF Controls */
        .pdf-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 6px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            height: 32px;
            flex-shrink: 0;
            z-index: 1;
        }

        .zoom-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-btn {
            padding: 3px 8px;
            border: none;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 12px;
        }

        .zoom-btn:hover {
            background-color: var(--accent-primary);
        }

        .zoom-level {
            min-width: 50px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Search Controls - Updated */
        .search-icon {
            padding: 2px;
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: color 0.2s ease;
        }

        .search-icon:hover {
            color: var(--accent-primary);
        }

        .search-modal {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 4px;
            display: none;
            z-index: 9999;
            width: 70%;
            max-width: 700px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: translateX(-50%) translateY(-20px);
        }

        .search-modal.active {
            display: block !important;
            opacity: 0.9 !important;
            visibility: visible !important;
            transform: translateX(-50%) translateY(0);
            animation: bounceDown 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes bounceDown {
            0% {
                transform: translateX(-50%) translateY(-20px);
            }
            70% {
                transform: translateX(-50%) translateY(5px);
            }
            100% {
                transform: translateX(-50%) translateY(0);
            }
        }

        .search-modal:not(.active) {
            animation: slideUp 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes slideUp {
            0% {
                transform: translateX(-50%) translateY(0);
                opacity: 0.9;
            }
            20% {
                transform: translateX(-50%) translateY(10px);
                opacity: 0.9;
            }
            100% {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0;
            }
        }

        .search-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .search-modal-header span {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .search-modal-close {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 2px;
            font-size: 12px;
            transition: color 0.2s ease;
            margin-left: 4px;
        }

        .search-modal-close:hover {
            color: var(--accent-primary);
        }

        .search-modal-content {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 3px 6px;
            min-height: 32px;
        }

        .search-input-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            min-height: 24px;
            opacity: 0.95;
            margin-top: 2px;
        }

        .search-input-group i {
            font-size: 12px;
            opacity: 1;
            color: var(--text-secondary);
        }

        .search-input {
            flex: 1;
            border: none;
            background: none;
            color: var(--text-primary);
            padding: 2px 4px;
            font-size: 13px;
            outline: none;
            width: 100%;
            line-height: 1.2;
        }

        .search-navigation {
            display: flex;
            align-items: center;
            gap: 2px;
            border-left: 1px solid var(--border-color);
            padding-left: 4px;
        }

        .search-count {
            color: var(--text-secondary);
            font-size: 12px;
            min-width: 60px;
            text-align: center;
        }

        .search-nav-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 1px 4px;
            font-size: 12px;
            transition: color 0.2s ease;
        }

        .search-nav-btn:hover:not(:disabled) {
            color: var(--accent-primary);
        }

        .search-nav-btn:disabled {
            color: var(--text-secondary);
            cursor: not-allowed;
        }

        /* Current Page Indicator */
        .pdf-page.current-page {
            border: 2px solid var(--accent-primary);
        }

        /* Add resize handles */
        .resize-handle {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            cursor: col-resize;
            background-color: transparent;
            transition: background-color 0.2s ease;
            z-index: 100;
            padding: 0 12px;
            margin: 0 -12px;
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            top: 0;
            left: 12px;
            width: 2px;
            height: 100%;
            background-color: transparent;
            transition: background-color 0.2s ease;
        }

        .resize-handle:hover::after {
            background-color: var(--accent-primary);
        }

        .resize-handle.left {
            right: -1px;
        }

        .resize-handle.right {
            left: -1px;
        }

        /* Update sidebar styles */
        .sidebar {
            position: relative;
            width: 250px;
            min-width: 48px;
            max-width: 500px;
            height: 100vh;
            background-color: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: row;
            flex-shrink: 0;
            z-index: 10;
            margin: 0;
            padding: 0;
        }

        .sidebar.collapsed {
            width: 48px;
        }

        .sidebar.collapsed .sidebar-content {
            display: none;
        }

        .sidebar-nav {
            width: 48px;
            height: 100%;
            background-color: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 0;
            flex-shrink: 0;
        }

        .nav-button {
            width: 100%;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .nav-button:hover {
            color: var(--text-primary);
            background-color: var(--bg-hover);
        }

        .nav-button.active {
            color: var(--accent-primary);
            background-color: var(--bg-hover);
        }

        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: opacity 0.2s ease;
        }

        .sidebar-panel {
            flex: 1;
            display: none;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--bg-primary);
            margin: 0;
            padding: 0;
            width: 100%;
            position: relative;
        }

        .sidebar-panel.active {
            display: flex;
            background-color: var(--bg-primary);
        }

        /* Update the chat section to be inside the sidebar */
        .chat-section {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
            border: none;
            height: 100%;
        }

        .chat-messages {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 16px;
            padding-bottom: 90px; /* Add padding to prevent messages from being hidden behind input */
            background-color: var(--bg-primary);
            margin: 0;
            min-height: 0;
        }

        .message {
            margin-bottom: 16px;
            max-width: 85%;
        }

        .message.assistant {
            margin-right: auto;
        }

        .message.user {
            margin-left: auto;
        }

        .message-content {
            padding: 8px 12px;
            border-radius: 12px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* Chat input styles */
        .chat-input-container {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            padding: 12px;
            background-color: var(--bg-tertiary);
            border: 0px solid var(--border-color);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 48px;
            max-height: 200px;
            height: auto;
            z-index: 2;
        }

        .chat-input-blocker {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 90px;
            background-color: var(--bg-primary);
            z-index: 1;
        }

        .chat-input-container textarea {
            width: 100%;
            flex: 1;
            min-height: 24px;
            max-height: 150px;
            padding: 8px;
            border: 0px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.4;
            resize: none;
            outline: none;
            overflow-y: auto;
            display: block;
        }

        .chat-input-controls {
            width: 100%;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 12px;
            padding-top: 4px;
            flex-shrink: 0;
        }

        .model-select {
            position: relative;
            display: inline-block;
            margin-right: auto;
            align-items: left;
        }

        .model-select-button {
            padding: 4px 8px;
            border: none;
            background: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .model-select-button:hover {
            color: var(--text-primary);
        }

        .model-select-button i {
            font-size: 10px;
        }

        .model-dropdown {
            position: absolute;
            bottom: 100%;
            right: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 0;
            margin-bottom: 4px;
            min-width: 150px;
            display: none;
            z-index: 1000;
        }

        .model-dropdown.active {
            display: block;
        }

        .model-option {
            padding: 6px 12px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .model-option:hover {
            background-color: var(--bg-hover);
        }

        .model-option.active {
            color: var(--accent-primary);
        }

        .model-option i {
            font-size: 12px;
            opacity: 0;
        }

        .model-option.active i {
            opacity: 1;
        }

        .chat-input-container button {
            padding: 4px;
            font-size: 10px;
            gap: 4px;
            line-height: 1;
            margin: auto 0;
        }

        .chat-input-container button:hover {
            color: var(--accent-primary);
            background-color: var(--bg-hover);
        }

        /* Remove the old chat section styles */
        .chat-section {
            position: relative;
            border: none;
            width: auto;
            min-width: 0;
            max-width: none;
            height: 100%;
        }

        /* Override styles for proper PDF positioning */
        .workspace {
            display: flex;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-primary);
            margin: 0;
            padding: 0;
        }

        .main-content {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
            margin: 0;
            padding-left: 10px;
            left: 0;
        }

        .file-tree {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--bg-primary);
        }

        .file-tree-header {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-primary);
        }

        .file-tree-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            background-color: var(--bg-primary);
        }

        /* Folder selection styles */
        .folder-select-container {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }
        
        .folder-select-container .form-input {
            flex: 1;
            min-width: 0;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .folder-select-container .modal-btn {
            padding: 6px 12px;
            white-space: nowrap;
        }
        
        /* Empty workspace message */
        .empty-workspace-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            height: 100%;
            color: var(--text-secondary);
        }

        .empty-workspace-message i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .empty-workspace-message h3 {
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .empty-workspace-message p {
            margin-bottom: 16px;
            font-size: 14px;
            max-width: 300px;
        }
        
        /* Tree error styles */
        .tree-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }
        
        .tree-error i {
            font-size: 24px;
            margin-bottom: 8px;
            color: #e74c3c;
        }
        
        .tree-error p {
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .tree-retry-btn {
            padding: 4px 12px;
            background-color: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .tree-retry-btn:hover {
            background-color: var(--accent-hover);
        }
        
        .textLayer.search-active span,
        .textLayer.search-active div {
            color: transparent;
            opacity: 0.3;
        }
        
        .textLayer.search-active .search-highlight {
            background-color: rgba(255, 255, 0, 0.3);
            border-radius: 2px;
            opacity: 1;
            color: transparent;
            mix-blend-mode: multiply;
        }
        
        .textLayer.search-active .search-highlight.current {
            background-color: rgba(76, 175, 80, 0.5);
            border: 1px solid rgba(76, 175, 80, 0.8);
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }
        
        /* New search overlay approach */
        .pdf-page {
            position: relative;
        }
        
        .search-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
            /* Hide search overlays by default */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        
        /* Show search overlays only when the search modal is active */
        .modal-overlay#searchModal.active ~ .main-content .search-overlay {
            opacity: 1;
            visibility: visible;
        }
        
        /* Alternative selector for when the direct sibling selector doesn't work */
        body.search-active .search-overlay {
            opacity: 1;
            visibility: visible;
        }
        
        /* All matches are highlighted in yellow by default */
        .search-match {
            position: absolute;
            background-color: rgba(255, 255, 0, 0.3);
            border: 1px solid rgba(255, 255, 0, 0.5);
            border-radius: 2px;
            pointer-events: auto; /* Allow interaction */
            cursor: pointer;
            z-index: 10;
            transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        /* Hover effect for highlights */
        .search-match:hover {
            background-color: rgba(255, 255, 0, 0.5);
            border-color: rgba(255, 200, 0, 0.8);
            box-shadow: 0 0 3px rgba(255, 200, 0, 0.5);
        }
        
        /* Current match is highlighted in green */
        .search-match.current {
            background-color: rgba(76, 175, 80, 0.5);
            border: 1px solid rgba(76, 175, 80, 0.8);
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
            z-index: 11; /* Ensure current match is on top */
        }
        
        /* Hover effect for current match */
        .search-match.current:hover {
            background-color: rgba(76, 175, 80, 0.7);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.7);
        }
        
        /* Pulse animation for highlighting the current match */
        @keyframes pulse-highlight {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            50% { box-shadow: 0 0 0 6px rgba(76, 175, 80, 0.4); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }
        
        .search-match.pulse-highlight {
            animation: pulse-highlight 1s ease-out forwards;
        }
        
        /* Make sure highlights are not visible when search is not active */
        body:not(.search-active) .search-match,
        body:not(.search-active) .search-match.current {
            opacity: 0 !important;
            visibility: hidden !important;
            box-shadow: none !important;
        }
    </style>
</head>
<body class="workspace">
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-nav">
            <div class="sidebar-nav-top">
                <button class="nav-button active" id="fileTreeBtn" title="Files">
                    <i class="fas fa-folder"></i>
                </button>
                <button class="nav-button" id="chatBtn" title="Chat">
                    <i class="fas fa-comments"></i>
                </button>
            </div>
            <div class="sidebar-nav-bottom">
                <button class="nav-button" id="sidebarSettingsBtn" title="Settings">
                <i class="fas fa-cog"></i>
            </button>
        </div>
        </div>
        <div class="sidebar-content">
            <div class="sidebar-panel active" id="fileTreePanel">
        <div class="file-tree">
            <div class="file-tree-header">
                <div class="file-tree-actions">
                    <button class="action-btn" title="New note">
                        <i class="fas fa-file"></i>
                    </button>
                    <button class="action-btn" title="New folder">
                        <i class="fas fa-folder-plus"></i>
                    </button>
                    <button class="action-btn" title="Sort files">
                        <i class="fas fa-sort"></i>
                    </button>
                </div>
            </div>
            <div class="file-tree-content" id="fileTree">
                        <!-- File tree content -->
            </div>
                </div>
                </div>
            <div class="sidebar-panel" id="chatPanel">
                <div class="chat-section">
                    <div class="chat-messages" id="chatMessages">
                        <div class="message assistant">
                            <div class="message-content">
                                Hello! I'm here to help you analyze your documents. What would you like to know?
                            </div>
                        </div>
                    </div>
                    <div class="chat-input-blocker"></div>
                    <div class="chat-input-container">
                        <textarea 
                            id="chatInput" 
                            placeholder="Type your message here..."
                            rows="1"
                            oninput="if (this.scrollHeight > this.clientHeight) {
                                this.style.height = 'auto';
                                const newHeight = Math.min(this.scrollHeight, 150);
                                this.style.height = newHeight + 'px';
                                this.parentElement.style.height = Math.min(newHeight + 60, 200) + 'px';
                            }"
                        ></textarea>
                        <div class="chat-input-controls">
                            <div class="model-select">
                                <button class="model-select-button" id="modelSelectBtn">
                                    GPT-4 <i class="fas fa-chevron-down"></i>
                                </button>
                                <div class="model-dropdown" id="modelDropdown">
                                    <div class="model-option active">
                                        <span>GPT-4</span>
                                        <i class="fas fa-check"></i>
                                    </div>
                                    <div class="model-option">
                                        <span>GPT-3.5</span>
                                        <i class="fas fa-check"></i>
                                    </div>
                                    <div class="model-option">
                                        <span>Claude 3</span>
                                        <i class="fas fa-check"></i>
                                    </div>
                                </div>
                            </div>
                            <button id="sendMessage">
                                Send 
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- PDF Viewer Section -->
        <div class="pdf-section">
            <!-- PDF Controls - Updated -->
            <div class="pdf-controls">
                <div class="zoom-control">
                    <button id="zoomOut" class="zoom-btn"><i class="fas fa-search-minus"></i></button>
                    <span id="zoomLevel" class="zoom-level">100%</span>
                    <button id="zoomIn" class="zoom-btn"><i class="fas fa-search-plus"></i></button>
                </div>
                <div class="search-control">
                    <button id="pdfSearchBtn" class="search-icon"><i class="fas fa-search"></i></button>
                    </div>
            </div>
            <div class="pdf-viewer" id="pdfViewer">
                <div id="pdfContainer" class="pdf-container">
                    <div id="pdfPagesContainer" class="pdf-pages-container active"></div>
                </div>
                
                <!-- Markdown Viewer Section (inside the PDF viewer container) -->
                <div class="markdown-section" style="display: none;">
                    <div class="markdown-controls">
                        <div class="markdown-title" id="markdownTitle">Markdown Viewer</div>
                        <div class="markdown-view-controls">
                            <button class="view-mode-btn active" data-mode="edit">Edit</button>
                            <button class="view-mode-btn" data-mode="split">Split</button>
                            <button class="view-mode-btn" data-mode="preview">Preview</button>
                        </div>
                        <div class="markdown-editing-indicator">
                            <i class="fas fa-pen"></i> Editing
                        </div>
                    </div>
                    <div class="markdown-viewer">
                        <div id="markdownContainer" class="markdown-container">
                            <div class="markdown-split-view">
                                <div class="markdown-editor" id="markdownEditor"></div>
                                <div class="markdown-preview" id="markdownPreview"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="pdf-file-bar">
                <div class="pdf-files" id="pdfFiles">
                    <!-- PDF file tabs will be added here dynamically -->
                </div>
            </div>
        </div>
    </div>
    
    <style>
        /* Markdown Viewer Styles */
        .markdown-section {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-primary);
            z-index: 10;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        
        .markdown-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 6px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            height: 32px;
            flex-shrink: 0;
            z-index: 1;
        }
        
        .markdown-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .markdown-viewer {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background-color: var(--bg-primary);
            display: flex;
            flex-direction: column;
        }
        
        .markdown-container {
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
            font-size: 16px;
            color: var(--text-primary);
            width: 100%;
            height: 100%;
        }

        /* CodeMirror Customizations */
        .CodeMirror {
            height: auto;
            min-height: calc(100vh - 120px);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            line-height: 1.6;
        }

        .CodeMirror-focused {
            border-color: var(--accent-primary);
        }

        /* Editor and Preview split view */
        .markdown-split-view {
            display: flex;
            height: 100%;
            gap: 20px;
        }

        .markdown-editor {
            flex: 1;
            min-height: 300px;
        }

        .markdown-preview {
            flex: 1;
            overflow-y: auto;
            padding: 0 10px;
            border-left: 1px solid var(--border-color);
        }

        /* View mode controls */
        .markdown-view-controls {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        .view-mode-btn {
            border: none;
            background: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .view-mode-btn:hover {
            background-color: var(--bg-hover);
        }

        .view-mode-btn.active {
            background-color: var(--accent-primary);
            color: white;
        }

        /* Styling for indicators when editing */
        .markdown-line-editing {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .markdown-edit-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .markdown-editing-indicator {
            display: none;
            font-size: 12px;
            color: var(--text-secondary);
            margin-left: auto;
            align-items: center;
            gap: 5px;
        }

        .markdown-editing-indicator.active {
            display: flex;
        }
        
        /* Markdown save status indicator */
        .markdown-save-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--accent-primary);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            animation: fadeIn 0.3s ease-in-out, fadeOut 0.3s ease-in-out 1.7s forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(10px); }
        }
        
        /* Markdown loading indicator */
        .markdown-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            color: var(--text-secondary);
            gap: 16px;
            padding: 40px 0;
        }
        
        .markdown-loading i {
            font-size: 32px;
            color: var(--accent-primary);
        }
        
        /* Markdown error display */
        .markdown-error {
            padding: 16px;
            background-color: rgba(220, 53, 69, 0.1);
            color: var(--danger);
            border-radius: 4px;
            margin: 16px 0;
            border-left: 4px solid var(--danger);
        }
        
        /* Markdown Content Styles */
        .markdown-container h1 {
            font-size: 1.8em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            padding-bottom: 0.3em;
            border-bottom: 1px solid var(--border-color);
        }
        
        .markdown-container h2 {
            font-size: 1.5em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            padding-bottom: 0.3em;
            border-bottom: 1px solid var(--border-color);
        }
        
        .markdown-container h3 {
            font-size: 1.25em;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }
        
        .markdown-container h4, .markdown-container h5, .markdown-container h6 {
            font-size: 1em;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }
        
        .markdown-container p {
            margin-bottom: 1em;
        }
        
        .markdown-container ul, .markdown-container ol {
            margin-bottom: 1em;
            padding-left: 2em;
        }
        
        .markdown-container li {
            margin-bottom: 0.5em;
        }
        
        .markdown-container code {
            font-family: 'Courier New', Courier, monospace;
            padding: 0.2em 0.4em;
            background-color: var(--bg-secondary);
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .markdown-container pre {
            margin-bottom: 1em;
            padding: 1em;
            overflow-x: auto;
            background-color: var(--bg-secondary);
            border-radius: 4px;
        }
        
        .markdown-container pre code {
            padding: 0;
            background-color: transparent;
        }
        
        .markdown-container blockquote {
            padding-left: 1em;
            margin-left: 0;
            border-left: 4px solid var(--accent-primary);
            color: var(--text-secondary);
        }
        
        .markdown-container a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        .markdown-container a:hover {
            text-decoration: underline;
        }
        
        .markdown-container table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }
        
        .markdown-container th, .markdown-container td {
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            text-align: left;
        }
        
        .markdown-container th {
            background-color: var(--bg-secondary);
        }
        
        .markdown-container img {
            max-width: 100%;
            height: auto;
        }
    </style>

    <!-- Search Modal - Added for PDF search functionality -->
    <div id="searchModal" class="search-modal">
        <div class="search-modal-header">
            <span>Search in PDF</span>
            <button id="closeSearchModal" class="search-modal-close">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="search-modal-content">
            <div class="search-input-group">
                <i class="fas fa-search"></i>
                <input type="text" id="pdfSearchInput" class="search-input" placeholder="Search in document...">
            </div>
            <div class="search-navigation">
                <button id="prevResult" class="search-nav-btn" disabled>
                    <i class="fas fa-chevron-up"></i>
                </button>
                <button id="nextResult" class="search-nav-btn" disabled>
                    <i class="fas fa-chevron-down"></i>
                </button>
                <span id="searchCount" class="search-count">No results</span>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-window">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button class="modal-close" onclick="directCloseModal('settingsModal')"><i class="fas fa-times"></i></button>
            </div>
            <div class="modal-body">
                <div class="settings-wrapper">
                    <div class="settings-sidebar">
                        <ul>
                            <li data-setting="appearance" class="active">
                                <i class="fas fa-palette"></i>
                                Appearance
                            </li>
                            <li data-setting="editor">
                                <i class="fas fa-edit"></i>
                                Editor
                            </li>
                            <li data-setting="pdf-viewer">
                                <i class="fas fa-file-pdf"></i>
                                PDF Viewer
                            </li>
                            <li data-setting="about">
                                <i class="fas fa-info-circle"></i>
                                About
                            </li>
                        </ul>
                    </div>
                    <div class="settings-content">
                        <!-- Appearance Panel -->
                        <div id="appearance-panel" class="settings-panel">
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Theme</div>
                                    <div class="settings-item-description">Choose between light and dark theme</div>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="themeToggle">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Font Size</div>
                                    <div class="settings-item-description">Adjust the base font size for the application</div>
                                </div>
                                <select class="settings-select" id="fontSize">
                                    <option value="12">12px</option>
                                    <option value="14">14px</option>
                                    <option value="16" selected>16px</option>
                                    <option value="18">18px</option>
                                </select>
                            </div>
                        </div>

                        <!-- Editor Panel -->
                        <div id="editor-panel" class="settings-panel" style="display: none;">
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Auto Save</div>
                                    <div class="settings-item-description">Automatically save changes as you type</div>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="autoSave" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Spell Check</div>
                                    <div class="settings-item-description">Enable spell checking in the editor</div>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="spellCheck">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Disable Popups</div>
                                    <div class="settings-item-description">Disable confirmation dialogs when deleting or renaming items</div>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="disablePopups">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>

                        <!-- PDF Viewer Panel -->
                        <div id="pdf-viewer-panel" class="settings-panel" style="display: none;">
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Default Zoom Level</div>
                                    <div class="settings-item-description">Set the default zoom level for PDFs</div>
                                </div>
                                <select class="settings-select" id="defaultZoom">
                                    <option value="0.5">50%</option>
                                    <option value="0.75">75%</option>
                                    <option value="1" selected>100%</option>
                                    <option value="1.25">125%</option>
                                    <option value="1.5">150%</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Smooth Scrolling</div>
                                    <div class="settings-item-description">Enable smooth scrolling in PDF viewer</div>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="smoothScroll" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Local Workspace Folder</div>
                                    <div class="settings-item-description">Select a local folder to use as your workspace</div>
                                </div>
                                <div class="folder-select-container">
                                    <input type="text" id="workspacePath" class="form-input" readonly placeholder="No folder selected">
                                    <button id="selectWorkspaceFolder" class="modal-btn modal-btn-primary">Select Folder</button>
                                </div>
                            </div>
                        </div>

                        <!-- About Panel -->
                        <div id="about-panel" class="settings-panel" style="display: none;">
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Version</div>
                                    <div class="settings-item-description">1.0.0</div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div>
                                    <div class="settings-item-label">Created By</div>
                                    <div class="settings-item-description">Your Team Name</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- New Note Modal -->
    <div id="newNoteModal" class="modal-overlay">
        <div class="modal-window">
            <div class="modal-header">
                <h2 class="modal-title">New Note</h2>
                <button class="modal-close" onclick="directCloseModal('newNoteModal')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <form id="newNoteForm" onsubmit="event.preventDefault(); createNewNote();">
                    <div class="form-group">
                        <label for="noteName" class="form-label">Note Name</label>
                        <input type="text" id="noteName" class="form-input" placeholder="Enter note name" required>
                    </div>
                    <div class="form-group">
                        <label for="noteDescription" class="form-label">Description</label>
                        <textarea id="noteDescription" class="form-input" rows="3" placeholder="Enter note description"></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Attachments</label>
                        <div class="drop-zone">
                            <input type="file" id="noteFiles" multiple accept=".pdf,.doc,.docx,.txt,image/*" style="display: none;">
                            <div class="drop-zone-text">
                                <i class="fas fa-cloud-upload-alt"></i>
                                <span>Drop files here or click to upload</span>
                                <span class="small">Supports PDF, images, and documents</span>
                            </div>
                        </div>
                        <div class="file-list">
                            <ul id="selectedNoteFiles"></ul>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="directCloseModal('newNoteModal')">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="createNewNote()">Create Note</button>
            </div>
        </div>
    </div>

    <!-- New Folder Modal -->
    <div id="newFolderModal" class="modal-overlay">
        <div class="modal-window">
            <div class="modal-header">
                <h2 class="modal-title">New Folder</h2>
                <button class="modal-close" onclick="directCloseModal('newFolderModal')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <form id="newFolderForm" onsubmit="event.preventDefault(); createNewFolder();">
                    <div class="form-group">
                        <label for="folderName" class="form-label">Folder Name</label>
                        <input type="text" id="folderName" class="form-input" placeholder="Enter folder name" required>
                    </div>
                    <div class="form-group">
                        <label for="folderDescription" class="form-label">Description</label>
                        <textarea id="folderDescription" class="form-input" rows="3" placeholder="Enter folder description"></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="directCloseModal('newFolderModal')">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="createNewFolder()">Create Folder</button>
            </div>
        </div>
    </div>
    
    <!-- Add this script right at the top to ensure loadPDF is available immediately -->
    <script>
        // Direct fallback implementation of loadPDF that will be available immediately
        window.loadPDF = function(url) {
            console.log('[Direct Fallback] Loading PDF from URL:', url);
            
            try {
                // Get the PDF viewer
                const pdfViewer = document.querySelector('.pdf-viewer');
                if (!pdfViewer) {
                    console.error('[Direct Fallback] PDF viewer not found');
                    return false;
                }
                
                // Show loading message
                pdfViewer.innerHTML = '<div class="pdf-loading"><i class="fas fa-spinner fa-spin"></i> Loading PDF...</div>';
                
                // Get or create the PDF container
                let pdfContainer = document.getElementById('pdfContainer');
                if (!pdfContainer) {
                    pdfContainer = document.createElement('div');
                    pdfContainer.id = 'pdfContainer';
                    pdfContainer.className = 'pdf-container';
                    pdfViewer.appendChild(pdfContainer);
                }
                
                // Get or create pdfPagesContainer
                let pdfPagesContainer = document.getElementById('pdfPagesContainer');
                if (!pdfPagesContainer) {
                    pdfPagesContainer = document.createElement('div');
                    pdfPagesContainer.id = 'pdfPagesContainer';
                    pdfPagesContainer.className = 'pdf-pages-container active';
                    pdfContainer.appendChild(pdfPagesContainer);
            } else {
                    pdfPagesContainer.classList.add('active');
                }
                
                // Check if PDF.js is loaded
                if (typeof pdfjsLib === 'undefined') {
                    console.error('[Direct Fallback] PDF.js library not loaded');
                    pdfContainer.innerHTML = '<div class="pdf-error">PDF.js library not loaded</div>';
                    return false;
                }
                
                try {
                    // Load the PDF using PDF.js
                    const loadingTask = pdfjsLib.getDocument(url);
                    
                    loadingTask.promise.then(function(pdf) {
                        console.log('[Direct Fallback] PDF loaded successfully, rendering pages');
                        
                        // Clear any existing content
                        pdfPagesContainer.innerHTML = '';
                        
                        // Store the PDF document reference
                        window.pdfDoc = pdf;
                        
                        // Render each page
                        const numPages = pdf.numPages;
                        console.log(`[Direct Fallback] PDF has ${numPages} pages`);
                        
                        // Use sequential rendering to ensure pages are in the correct order
                        let renderPromise = Promise.resolve();
                        
                        // Create array to store rendered pages in order
                        const renderedPages = new Array(numPages);
                        
                        // First, render all pages without adding them to the DOM yet
                        for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                            renderPromise = renderPromise.then(() => {
                                console.log(`[Direct Fallback] Starting to render page ${pageNum}`);
            return pdf.getPage(pageNum).then(function(page) {
                // Create a div for this page
                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.dataset.pageNumber = pageNum;
                
                                    // Create canvas for rendering
                const canvas = document.createElement('canvas');
                                    const context = canvas.getContext('2d');
                                    
                                    // Set canvas dimensions to match the PDF page
                                    const viewport = page.getViewport({ scale: 1.5 });
                canvas.width = viewport.width;
                                    canvas.height = viewport.height;
                                    
                                    // Render the PDF page to the canvas
                const renderContext = {
                                        canvasContext: context,
                    viewport: viewport
                };
                
                                    // Add the canvas to the page div
                                    pageDiv.appendChild(canvas);
                                    
                                    // Create text layer div
                                    const textLayerDiv = document.createElement('div');
                                    textLayerDiv.className = 'textLayer';
                                    pageDiv.appendChild(textLayerDiv);
                                    
                                    // Add page number indicator
                                    const pageNumDiv = document.createElement('div');
                                    pageNumDiv.className = 'page-number';
                                    pageNumDiv.textContent = pageNum;
                                    pageDiv.appendChild(pageNumDiv);
                                    
                                    // Store the page div in the array at its correct position (1-indexed)
                                    renderedPages[pageNum-1] = pageDiv;
                                    
                                    // Render the page
                                    return page.render(renderContext).promise.then(function() {
                                        // Get the text content
                                        return page.getTextContent();
                                    }).then(function(textContent) {
                                        // Create text layer
                        const textLayer = document.createElement('div');
                        textLayer.className = 'textLayer';
                                        
                                        // Position text layer over the canvas
                                        textLayer.style.left = canvas.offsetLeft + 'px';
                                        textLayer.style.top = canvas.offsetTop + 'px';
                                        textLayer.style.width = canvas.width + 'px';
                                        textLayer.style.height = canvas.height + 'px';
                                        
                                        // Add text layer to page
                                        pageDiv.appendChild(textLayer);
                                        
                                        // Group text items by their vertical position (lines)
                                        const lines = {};
                                        const lineHeight = 1.2; // multiplier for line height
                                        const tolerance = 5; // pixels of tolerance for same line detection

                                        // First pass: group text items by vertical position
                                        textContent.items.forEach(function(item) {
                                            // Transform the item position
                                            const tx = pdfjsLib.Util.transform(
                                                viewport.transform,
                                                item.transform
                                            );
                                            
                                            // Get baseline position (vertical)
                                            const baseline = Math.round(tx[5]);
                                            
                                            // Either add to existing line or create new line
                                            let foundLine = false;
                                            for (const key in lines) {
                                                const lineY = parseInt(key);
                                                if (Math.abs(baseline - lineY) <= tolerance) {
                                                    lines[key].push({
                                                        text: item.str,
                                                        x: tx[4],
                                                        y: baseline,
                                                        fontSize: tx[0],
                                                        fontFamily: item.fontName || 'sans-serif'
                                                    });
                                                    foundLine = true;
                                                    break;
                                                }
                                            }
                                            
                                            if (!foundLine) {
                                                lines[baseline] = [{
                                                    text: item.str,
                                                    x: tx[4],
                                                    y: baseline,
                                                    fontSize: tx[0],
                                                    fontFamily: item.fontName || 'sans-serif'
                                                }];
                                            }
                                        });
                                        
                                        // Process text chunks
                                        Object.keys(lines).forEach(function(baseline) {
                                            // Sort items in this line by x position
                                            const lineItems = lines[baseline].sort((a, b) => a.x - b.x);
                                            
                                            // Find chunks of text with similar characteristics
                                            const chunks = [];
                                            let currentChunk = [];
                                            let prevItem = null;
                                            
                                            lineItems.forEach(function(item) {
                                                if (!prevItem) {
                                                    // First item in line
                                                    currentChunk.push(item);
                                                } else {
                                                    // Check if this item should be part of the current chunk
                                                    const gap = item.x - (prevItem.x + prevItem.text.length * prevItem.fontSize * 0.5);
                                                    
                                                    if (gap < 10 && item.fontSize === prevItem.fontSize) {
                                                        // Same chunk - small gap and same font size
                                                        currentChunk.push(item);
                                                    } else {
                                                        // New chunk
                                                        chunks.push(currentChunk);
                                                        currentChunk = [item];
                                                    }
                                                }
                                                prevItem = item;
                                            });
                                            
                                            // Add the last chunk if not empty
                                            if (currentChunk.length > 0) {
                                                chunks.push(currentChunk);
                                            }
                                            
                                            // Create spans for each chunk
                                            chunks.forEach(function(chunk) {
                                                if (chunk.length === 0) return;
                                                
                                                // Get first and last items for positioning
                                                const firstItem = chunk[0];
                                                const lastItem = chunk[chunk.length - 1];
                                                
                                                // Create text span
                                                const span = document.createElement('span');
                                                span.className = 'text-chunk';
                                                
                                                // Combine text from all items in this chunk
                                                span.textContent = chunk.map(item => item.text).join('');
                                                
                                                // Position the span
                                                span.style.position = 'absolute';
                                                span.style.left = `${firstItem.x}px`;
                                                span.style.top = `${firstItem.y - firstItem.fontSize}px`;
                                                span.style.fontSize = `${firstItem.fontSize}px`;
                                                span.style.fontFamily = firstItem.fontFamily;
                                                span.style.transform = 'scaleX(1.0)';
                                                span.style.transformOrigin = '0% 0%';
                                                span.style.color = 'transparent';
                                                span.style.whiteSpace = 'pre';
                                                
                                                // Add span to text layer
                                                textLayer.appendChild(span);
                                            });
                                        });
                                        
                                        console.log(`[Direct Fallback] Rendered page ${pageNum} with grouped text`);
                                return pageDiv;
                            });
                                });
                            });
                        }
                        
                        // After all pages are rendered, add them to the container in the correct order
                        renderPromise.then(() => {
                            console.log('[Direct Fallback] All pages rendered, adding to container in order');
                            
                            // Add pages to container in correct order
                            renderedPages.forEach((pageDiv, index) => {
                                if (pageDiv) {
                                    console.log(`[Direct Fallback] Adding page ${index + 1} to container`);
                                    pdfPagesContainer.appendChild(pageDiv);
                                } else {
                                    console.warn(`[Direct Fallback] Page ${index + 1} was not rendered properly`);
                                }
                            });
                            
                            console.log('[Direct Fallback] All pages added to container');
                            
                            // Remove loading indicator
                            const loadingIndicator = pdfViewer.querySelector('.pdf-loading');
                            if (loadingIndicator) {
                                loadingIndicator.remove();
                            }
                            
                            // Adjust text spans if needed
                            if (typeof adjustTextSpanStyles === 'function') {
                                // Find all text layers and apply adjustments to each
                                const textLayers = document.querySelectorAll('.textLayer');
                                textLayers.forEach(function(textLayer) {
                                    try {
                                adjustTextSpanStyles(textLayer);
                                    } catch (e) {
                                        console.warn('[Direct Fallback] Error adjusting text spans:', e);
                                    }
                                });
                            }
                            
                            // Hide the skeleton screen if present
                            if (typeof hideSkeletonScreen === 'function') {
                                hideSkeletonScreen();
                            }
                            
                            return true;
                        }).catch(function(error) {
                            console.error('[Direct Fallback] Error rendering PDF pages:', error);
                            pdfContainer.innerHTML = `<div class="pdf-error">Error rendering PDF: ${error.message}</div>`;
                            return false;
                        });
                        
                        return true;
                    }).catch(function(error) {
                        console.error('[Direct Fallback] Error loading PDF:', error);
                        pdfContainer.innerHTML = `<div class="pdf-error">Error loading PDF: ${error.message}</div>`;
                        return false;
                    });
                    
                    return true;
                } catch (error) {
                    console.error('[Direct Fallback] Error in PDF loading process:', error);
                    pdfContainer.innerHTML = `<div class="pdf-error">Error: ${error.message}</div>`;
                    return false;
                }
            } catch (error) {
                console.error('[Direct Fallback] Unexpected error:', error);
                return false;
            }
        };
        
        console.log('[Direct Fallback] loadPDF function added to window object');
        
        // Add fallback for adjustTextSpanStyles function
        if (typeof window.adjustTextSpanStyles !== 'function') {
            window.adjustTextSpanStyles = function(textLayer) {
                console.log('[Fallback] Adjusting text spans in text layer');
                const textSpans = textLayer.querySelectorAll('span');
                
                // Process each text span
                textSpans.forEach(span => {
                    // Get original style
                    const originalStyle = span.getAttribute('style') || '';
                    
                    // Don't modify styles if they already have a transform
                    if (originalStyle.includes('transform:')) {
                        return;
                    }
                    
                    // Extract positioning styles to preserve them
                    const leftMatch = originalStyle.match(/left:\s*([^;]+)/);
                    const topMatch = originalStyle.match(/top:\s*([^;]+)/);
                    const fontSizeMatch = originalStyle.match(/font-size:\s*([^;]+)/);
                    const fontFamilyMatch = originalStyle.match(/font-family:\s*([^;]+)/);
                    const transformMatch = originalStyle.match(/transform:\s*([^;]+)/);
                    
                    // Create new style preserving original positioning exactly
                    let newStyle = originalStyle;
                    
                    // Only add the transform if one isn't already present
                    if (!transformMatch) {
                        newStyle += ' transform: scaleX(1.0); transform-origin: 0% 0%;';
                    }
                    
                    // Apply the new style
                    span.setAttribute('style', newStyle);
                    span.setAttribute('role', 'presentation');
                });
                
                console.log(`[Fallback] Adjusted ${textSpans.length} text spans`);
            };
            
            console.log('[Direct Fallback] Added fallback adjustTextSpanStyles function');
        }
        
        // Add fallback search function if not available
        if (typeof window.searchPDF !== 'function') {
            // Track search state
            let searchState = {
                searchText: '',
                matches: [],
                currentMatchIndex: -1,
                overlays: []
            };
            
            // Helper to clear previous search highlights
            function clearSearchHighlights() {
                // Remove all search overlays - this will remove all highlight elements
                searchState.overlays.forEach(overlay => {
                    if (overlay && overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                });
                searchState.overlays = [];
                
                // Reset search state
                searchState.matches = [];
                searchState.currentMatchIndex = -1;
            }
            
            // Main search function - simplified approach for text chunks
            window.searchPDF = function(searchText) {
                console.log('[PDF Search] Searching PDF for:', searchText);
                
                // Clear previous highlights
                clearSearchHighlights();
                
                if (!searchText || searchText.trim() === '') {
                    return false;
                }
                
                // Update search state
                searchState.searchText = searchText.trim().toLowerCase();
                
                try {
                    // Get all PDF pages
                    const pdfPages = document.querySelectorAll('.pdf-page');
                    const allMatches = [];
                    
                    // Process each page
                    pdfPages.forEach((page, pageIndex) => {
                        // Create a search overlay for this page
                        const overlay = document.createElement('div');
                        overlay.className = 'search-overlay';
                        page.appendChild(overlay);
                        searchState.overlays.push(overlay);
                        
                        // Get all text chunks in this page
                        const textChunks = page.querySelectorAll('.text-chunk, span');
                        
                        // Find matches in text chunks
                        textChunks.forEach(chunk => {
                            const chunkText = chunk.textContent || '';
                            const chunkTextLower = chunkText.toLowerCase();
                            const searchTextLower = searchState.searchText.toLowerCase();
                            
                            // Skip empty chunks
                            if (!chunkText) return;
                            
                            // Find all occurrences of the search text in this chunk
                            let startIndex = 0;
                            
                            while (true) {
                                const matchIndex = chunkTextLower.indexOf(searchTextLower, startIndex);
                                if (matchIndex === -1) break;
                                
                                // Calculate the position of this specific match
                                const chunkRect = chunk.getBoundingClientRect();
                                const pageRect = page.getBoundingClientRect();
                                
                                // Create a temp element to measure text width precisely
                                const measureElement = document.createElement('span');
                                // Copy the styles from the chunk
                                const computedStyle = window.getComputedStyle(chunk);
                                measureElement.style.fontFamily = computedStyle.fontFamily;
                                measureElement.style.fontSize = computedStyle.fontSize;
                                measureElement.style.fontWeight = computedStyle.fontWeight;
                                measureElement.style.letterSpacing = computedStyle.letterSpacing;
                                measureElement.style.visibility = 'hidden';
                                measureElement.style.position = 'absolute';
                                measureElement.style.whiteSpace = 'pre';
                                document.body.appendChild(measureElement);
                                
                                // Measure text before the match
                                measureElement.textContent = chunkText.substring(0, matchIndex);
                                const preMatchWidth = measureElement.getBoundingClientRect().width;
                                
                                // Measure the match text itself
                                measureElement.textContent = chunkText.substring(matchIndex, matchIndex + searchState.searchText.length);
                                const matchWidth = measureElement.getBoundingClientRect().width;
                                
                                // Clean up
                                document.body.removeChild(measureElement);
                                
                                // Calculate the exact offset for the highlight
                                const transformMatch = chunk.style.transform ? chunk.style.transform.match(/scaleX\(([^)]+)\)/) : null;
                                const scaleX = transformMatch ? parseFloat(transformMatch[1]) : 1;
                                const matchOffsetLeft = parseInt(chunk.style.left || '0') + (preMatchWidth * scaleX);
                                
                                // Create highlight element for this match only
                                const highlight = document.createElement('div');
                                highlight.className = 'search-match';
                                highlight.setAttribute('data-match-index', allMatches.length);
                                
                                // Make highlights clickable
                                highlight.style.pointerEvents = 'auto';
                                highlight.style.cursor = 'pointer';
                                highlight.addEventListener('click', function() {
                                    const matchIndex = parseInt(this.getAttribute('data-match-index'), 10);
                                    navigateToMatch(matchIndex);
                                });
                                
                                // Position highlight only over the matched text
                                highlight.style.left = `${matchOffsetLeft}px`;
                                highlight.style.top = chunk.style.top;
                                highlight.style.width = `${matchWidth}px`;
                                highlight.style.height = `${parseInt(chunk.style.fontSize || '16')}px`;
                                
                                // If the chunk has a transform, apply it to the highlight too
                                if (chunk.style.transform) {
                                    highlight.style.transform = chunk.style.transform;
                                    highlight.style.transformOrigin = '0% 0%';
                                }
                                
                                // Add to overlay
                                overlay.appendChild(highlight);
                                
                                // Add to matches array
                                allMatches.push({
                                    text: chunkText.substring(matchIndex, matchIndex + searchState.searchText.length),
                                    chunk: chunk,
                                    highlight: highlight,
                                    page: page,
                                    pageIndex: pageIndex,
                                    matchIndex: matchIndex
                                });
                                
                                // Move to next potential match
                                startIndex = matchIndex + 1;
                            }
                        });
                    });
                    
                    // Update search state
                    searchState.matches = allMatches;
                    
                    // If we found any matches, navigate to the first one
                    if (allMatches.length > 0) {
                        // All matches are already highlighted in yellow
                        // Now highlight the first match in green
                        searchState.currentMatchIndex = 0;
                        navigateToMatch(0);
                    }
                    
                    // Update UI
                    const searchCount = document.getElementById('searchCount');
                    if (searchCount) {
                        searchCount.textContent = allMatches.length > 0 ? 
                            `1/${allMatches.length}` : 'No results';
                    }
                    
                    // Update navigation buttons
                    const prevResultBtn = document.getElementById('prevResult');
                    const nextResultBtn = document.getElementById('nextResult');
                    if (prevResultBtn) prevResultBtn.disabled = allMatches.length <= 1;
                    if (nextResultBtn) nextResultBtn.disabled = allMatches.length <= 1;
                    
                    return allMatches.length > 0;
                } catch (error) {
                    console.error('[PDF Search] Error searching:', error);
                    return false;
                }
            };
            
            // Function to navigate to a specific match
            function navigateToMatch(index) {
                if (searchState.matches.length === 0) return;
                
                // Make sure index is in bounds
                index = Math.max(0, Math.min(index, searchState.matches.length - 1));
                
                // Remove 'current' class from all highlights, but keep them visible
                searchState.matches.forEach(match => {
                    if (match.highlight) match.highlight.classList.remove('current');
                });
                
                // Get current match
                const currentMatch = searchState.matches[index];
                
                // Add current class to the current match
                if (currentMatch && currentMatch.highlight) {
                    currentMatch.highlight.classList.add('current');
                    
                    // Get the element's position information
                    const element = currentMatch.highlight;
                    
                    // Wait a short moment to ensure DOM is updated
                    setTimeout(() => {
                        // Get element's position relative to the document
                        const rect = element.getBoundingClientRect();
                        
                        // Calculate window's middle point
                        const windowHeight = window.innerHeight;
                        const windowMiddle = windowHeight / 2;
                        
                        // Calculate how far element is from middle of window
                        const elementMiddle = rect.top + (rect.height / 2);
                        const distanceFromMiddle = elementMiddle - windowMiddle;
                        
                        // Scroll by that distance to center the element
                        window.scrollBy({
                            top: distanceFromMiddle,
                            behavior: 'smooth'
                        });
                        
                        // Add pulse animation
                        element.classList.add('pulse-highlight');
                        setTimeout(() => {
                            if (element.classList) element.classList.remove('pulse-highlight');
                        }, 1000);
                    }, 50);
                }
                
                // Update UI
                const searchCount = document.getElementById('searchCount');
                if (searchCount) {
                    searchCount.textContent = `${index + 1}/${searchState.matches.length}`;
                }
                
                // Update state
                searchState.currentMatchIndex = index;
            }
            
            // Navigation functions
            window.nextSearchResult = function() {
                if (searchState.matches.length === 0) return;
                
                const nextIndex = (searchState.currentMatchIndex + 1) % searchState.matches.length;
                navigateToMatch(nextIndex);
            };
            
            window.prevSearchResult = function() {
                if (searchState.matches.length === 0) return;
                
                const prevIndex = (searchState.currentMatchIndex - 1 + searchState.matches.length) % searchState.matches.length;
                navigateToMatch(prevIndex);
            };
            
            console.log('[PDF Search] Added simplified search functions');
        }
    </script>

    <!-- Ensure PDF.js is loaded -->
    <script>
        // Check if PDF.js is already loaded
        if (typeof pdfjsLib === 'undefined') {
            console.log('Loading PDF.js library');
            
            // Create script element for PDF.js
            const pdfJsScript = document.createElement('script');
            pdfJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js';
            pdfJsScript.integrity = 'sha512-ysGZ5eGTEg6WRJJNfEC1OEL53zQfBMA4jSS+lqJutJnwuEjFqIzLwE9rig6H5O4S0QrNX+7GY8PFDiDQlLPJw==';
            pdfJsScript.crossOrigin = 'anonymous';
            pdfJsScript.referrerPolicy = 'no-referrer';
            pdfJsScript.onload = function() {
                console.log('PDF.js library loaded successfully');
                
                // Set worker source after library loads
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
                    console.log('PDF.js worker source set');
                }
            };
            pdfJsScript.onerror = function() {
                console.error('Failed to load PDF.js library');
            };
            
            // Append script to document
            document.head.appendChild(pdfJsScript);
        } else {
            console.log('PDF.js library already loaded');
        }
    </script>

    <!-- Before the existing scripts, add this script tag to ensure PDF.js functions are available -->
    <script>
        // Ensure PDF.js is properly loaded before continuing
        document.addEventListener('DOMContentLoaded', function() {
            // Load PDF.js script if needed
            if (typeof pdfjsLib === 'undefined') {
                console.error('[Workspace] PDF.js library not found, adding script tag');
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                document.head.appendChild(script);
            }
            
            // First, load our custom PDF.js module
            const scriptElement = document.createElement('script');
            scriptElement.src = '/frontend/src/js/pdf.js';
            scriptElement.type = 'text/javascript';
            
            scriptElement.onload = function() {
                console.log('[Workspace] PDF.js script loaded successfully');
                
                // Check if functions were exported to global scope
                if (typeof window.loadPDF !== 'function') {
                    console.warn('[Workspace] loadPDF not found in global scope after script load, creating fallback');
                    
                    // Create a simple fallback if the function doesn't exist
                    window.loadPDF = function(url) {
                        console.log('[Fallback] Using fallback loadPDF function');
                        
                        // Get containers
                        const pdfViewer = document.querySelector('.pdf-viewer');
                        if (!pdfViewer) return false;
                        
                        // Show loading state
                        pdfViewer.innerHTML = '<div class="pdf-loading"><i class="fas fa-spinner fa-spin"></i> Loading PDF (fallback)...</div>';
                        
                        // Create or get container
                        let pdfContainer = document.getElementById('pdfContainer');
                        if (!pdfContainer) {
                            pdfContainer = document.createElement('div');
                            pdfContainer.id = 'pdfContainer';
                            pdfContainer.className = 'pdf-container';
                            pdfViewer.appendChild(pdfContainer);
                        }
                        
                        // Get pdfPagesContainer
                        let pdfPagesContainer = document.getElementById('pdfPagesContainer');
                        if (!pdfPagesContainer) {
                            pdfPagesContainer = document.createElement('div');
                            pdfPagesContainer.id = 'pdfPagesContainer';
                            pdfPagesContainer.className = 'pdf-pages-container active';
                            pdfContainer.appendChild(pdfPagesContainer);
                        }
                        
                        if (typeof pdfjsLib === 'undefined') {
                            console.error('[Fallback] PDF.js library not loaded');
                            pdfContainer.innerHTML = '<div class="pdf-error">PDF.js library not loaded</div>';
                            return false;
                        }
                        
                        try {
                            // Load the PDF using PDF.js
                            const loadingTask = pdfjsLib.getDocument(url);
                            loadingTask.promise.then(function(pdf) {
                                console.log(`[Fallback] PDF loaded successfully with ${pdf.numPages} pages`);
                                
                                // Clear container
                                pdfPagesContainer.innerHTML = '';
                                
                                // Keep track of promises for all page renders
                                const renderPromises = [];
                                
                                // Render each page sequentially to ensure order
                                function renderPagesSequentially(startPage) {
                                    if (startPage > pdf.numPages) {
                                        console.log('[Fallback] All pages rendered successfully');
                                        return Promise.resolve();
                                    }
                                    
                                    return pdf.getPage(startPage).then(function(page) {
                                        // Create page container
                                        const pageContainer = document.createElement('div');
                                        pageContainer.className = 'pdf-page';
                                        pageContainer.dataset.pageNumber = startPage;
                                        
                                        // Set viewport
                                        const scale = 1.0;
                                        const viewport = page.getViewport({ scale });
                                        
                                        // Create canvas
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');
                                        canvas.height = viewport.height;
                                        canvas.width = viewport.width;
                                        
                                        // Set size on container
                                        pageContainer.style.width = `${viewport.width}px`;
                                        pageContainer.style.height = `${viewport.height}px`;
                                        
                                        // Wrapper for canvas
                                        const wrapper = document.createElement('div');
                                        wrapper.className = 'pdf-page-wrapper';
                                        wrapper.style.width = `${viewport.width}px`;
                                        wrapper.style.height = `${viewport.height}px`;
                                        wrapper.style.position = 'relative';
                                        
                                        // Render to canvas
                                        return page.render({
                                            canvasContext: ctx,
                                            viewport: viewport
                                        }).promise.then(function() {
                                            // Add page number
                        const pageNumberDiv = document.createElement('div');
                        pageNumberDiv.className = 'page-number';
                                            pageNumberDiv.textContent = startPage;
                                            
                                            // Add everything to the DOM
                                            wrapper.appendChild(canvas);
                                            wrapper.appendChild(textLayer);
                                            pageContainer.appendChild(wrapper);
                                            pageContainer.appendChild(pageNumberDiv);
                                            pdfPagesContainer.appendChild(pageContainer);
                                            
                                            console.log(`[Fallback] Page ${startPage} rendered successfully`);
                                            
                                            // Render next page
                                            return renderPagesSequentially(startPage + 1);
                    });
            });
                                }
                                
                                // Start rendering from page 1
                                renderPagesSequentially(1);
                            }).catch(function(error) {
                                console.error('[Fallback] Error loading PDF:', error);
                                pdfContainer.innerHTML = `<div class="pdf-error">Error loading PDF: ${error.message}</div>`;
                            });
                            
                            return true;
                        } catch (error) {
                            console.error('[Fallback] Error in PDF loading process:', error);
                            pdfContainer.innerHTML = `<div class="pdf-error">Error: ${error.message}</div>`;
                            return false;
                        }
                    };
                }
            };
            
            scriptElement.onerror = function() {
                console.error('[Workspace] Failed to load PDF.js script');
            };
            
            // Add script to document head
            document.head.appendChild(scriptElement);
        });
    </script>

    <!-- Existing scripts -->
    <script src="/frontend/src/js/pdf.js"></script>
    <script src="/frontend/src/js/filetree.js"></script>
    <script>
        // Make sure PDF functions are available
        function ensurePDFFunctionsAvailable() {
            if (typeof window.loadPDF !== 'function') {
                console.error('[Workspace] loadPDF function not found in global scope!');
                
                // Add it to window if it exists in the module
                if (typeof loadPDF === 'function') {
                    console.log('[Workspace] Adding loadPDF function to window object');
                    window.loadPDF = loadPDF;
                }
            } else {
                console.log('[Workspace] loadPDF function is available');
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            // Ensure PDF functions are available
            ensurePDFFunctionsAvailable();
            
            // Initialize file tree
            renderFileTree();
            
            // Initialize PDF viewer
            const pdfContainer = document.getElementById('pdfContainer');
            if (pdfContainer) {
                console.log('[Workspace] PDF container found, initializing PDF viewer');
                if (typeof window.initPDF === 'function') {
                    window.initPDF();
                }
            }
            
            // Set up search functionality
            setupPDFSearch();
            
            // Automatically test the PDF rendering after a short delay
            setTimeout(function() {
                console.log('[Workspace] Auto-testing PDF rendering');
                if (typeof testDirectPDFRendering === 'function') {
                    testDirectPDFRendering();
                }
            }, 1000);
            
            console.log('[Workspace] Application initialized');
        });
        
        // Setup search functionality
        function setupPDFSearch() {
            console.log('[Workspace] Setting up PDF search functionality');
            
            // Get search elements
            const searchBtn = document.getElementById('pdfSearchBtn');
            const searchModal = document.getElementById('searchModal');
            const closeSearchModal = document.getElementById('closeSearchModal');
            const searchInput = document.getElementById('pdfSearchInput');
            const prevResultBtn = document.getElementById('prevResult');
            const nextResultBtn = document.getElementById('nextResult');
            
            // Add search button click handler
            if (searchBtn) {
                searchBtn.addEventListener('click', function() {
                    if (searchModal) {
                        searchModal.classList.add('active');
                        // Add search-active class to body when opening search
                        document.body.classList.add('search-active');
                        if (searchInput) {
                            searchInput.focus();
                        }
                    }
                });
            }
            
            // Function to close search modal and clean up highlights
            function directCloseSearchModal() {
                console.log('[Search] Directly closing search modal and clearing highlights');
                
                // Hide the modal
                if (searchModal) {
                    searchModal.classList.remove('active');
                }
                
                // Remove 'current' class from all matches to prevent leftover highlights
                const currentMatches = document.querySelectorAll('.search-match.current');
                currentMatches.forEach(match => {
                    match.classList.remove('current');
                    match.classList.remove('pulse-highlight');
                });
                
                // Remove search-active class from body
                document.body.classList.remove('search-active');
                
                // Reset search input
                if (searchInput) {
                    searchInput.value = '';
                }
                
                // Reset search state
                if (typeof searchState !== 'undefined') {
                    searchState.currentMatchIndex = -1;
                }
            }
            
            // Add close button click handler
            if (closeSearchModal) {
                closeSearchModal.addEventListener('click', function() {
                    directCloseSearchModal();
                });
            }
            
            // Add search input keyup handler
            if (searchInput) {
                // Use an input event to trigger the search as the user types
                searchInput.addEventListener('input', function() {
                    // Only search if there's actual text to search for
                    if (searchInput.value && searchInput.value.trim().length > 0) {
                        // Add small delay to avoid searching on every keystroke
                        clearTimeout(searchInput.searchTimeout);
                        searchInput.searchTimeout = setTimeout(function() {
                            performSearch(searchInput.value);
                        }, 250); // 250ms delay for better performance
                    } else {
                        // If search input is empty, clear the search highlights
                        if (typeof window.clearSearchResults === 'function') {
                            window.clearSearchResults();
                        } else if (typeof window.searchPDF === 'function') {
                            window.searchPDF(''); // Passing empty string will clear results
                        }
                    }
                });
                
                // Keep the Enter key handler for immediate search
                searchInput.addEventListener('keyup', function(e) {
                    if (e.key === 'Enter') {
                        clearTimeout(searchInput.searchTimeout);
                        performSearch(searchInput.value);
                    } else if (e.key === 'Escape') {
                        // Close the search modal when Escape is pressed
                        directCloseSearchModal();
                    }
                });
            }
            
            // Add escape key listener to document to close search modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && searchModal && searchModal.classList.contains('active')) {
                    directCloseSearchModal();
                }
            });
            
            // Add previous/next result button handlers
            if (prevResultBtn) {
                prevResultBtn.addEventListener('click', function() {
                    if (typeof window.prevSearchResult === 'function') {
                        window.prevSearchResult();
                    }
                });
            }
            
            if (nextResultBtn) {
                nextResultBtn.addEventListener('click', function() {
                    if (typeof window.nextSearchResult === 'function') {
                        window.nextSearchResult();
                    }
                });
            }
            
            // Function to perform search
            function performSearch(text) {
                if (!text || text.trim() === '') {
                    return;
                }
                
                console.log(`[Search] Searching for: "${text}"`);
                
                // Use searchPDF function from pdf.js module if available
                if (typeof window.searchPDF === 'function') {
                    window.searchPDF(text);
                    
                    // Enable navigation buttons
                    if (prevResultBtn) prevResultBtn.disabled = false;
                    if (nextResultBtn) nextResultBtn.disabled = false;
                } else {
                    // Fallback to built-in browser search
                    window.find(text);
                }
            }
        }
        
        // Add error handler for script loading
        window.addEventListener('error', function(event) {
            if (event.filename && event.filename.includes('pdf.js')) {
                console.error('[PDF.js Error]', event.message);
            }
        });
    </script>
    
    <!-- Direct script for skeleton handling -->
    <script>
        // Function to hide the skeleton screen
        function hideSkeletonScreen() {
            console.log('[Workspace] Hiding skeleton screen directly');
            const skeleton = document.getElementById('pdfInitialSkeleton');
            if (skeleton) {
                skeleton.classList.add('hidden');
                skeleton.style.display = 'none';
                console.log('[Workspace] Skeleton screen hidden');
            }
        }
        
        // Function to show the skeleton screen
        function showSkeletonScreen() {
            console.log('[Workspace] Showing skeleton screen directly');
            const skeleton = document.getElementById('pdfInitialSkeleton');
            if (skeleton) {
                skeleton.classList.remove('hidden');
                skeleton.style.display = 'flex';
                console.log('[Workspace] Skeleton screen shown');
            }
        }
        
        // Add a mutation observer to detect when PDF pages are added
        document.addEventListener('DOMContentLoaded', function() {
            const pdfPagesContainer = document.getElementById('pdfPagesContainer');
            if (pdfPagesContainer) {
                console.log('[Workspace] Setting up mutation observer for PDF pages container');
                
                // Create a mutation observer to watch for changes
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            // Check if any PDF pages were added
                            const pdfPages = pdfPagesContainer.querySelectorAll('.pdf-page');
                            if (pdfPages.length > 0) {
                                console.log('[Workspace] PDF pages detected, hiding skeleton screen');
                                hideSkeletonScreen();
                            }
                        }
                    });
                });
                
                // Start observing the container for changes
                observer.observe(pdfPagesContainer, { childList: true, subtree: true });
            }
        });
    </script>
    
    <!-- Test function for direct PDF rendering -->
    <script>
        // Direct test function for PDF rendering
        function testDirectPDFRendering() {
            console.log('[Test] Using existing pdf.js functions to render PDF');
            
            // First ensure the PDF functions are available
            ensurePDFFunctionsAvailable();
            
            // Try different paths to find the correct one
            const possiblePaths = [
                '/assets/Files/final review.pdf',
                './assets/Files/final review.pdf',
                '../assets/Files/final review.pdf',
                '/frontend/public/assets/Files/final review.pdf',
                'frontend/public/assets/Files/final review.pdf'
            ];
            
            let pathIndex = 0;
            
            function tryNextPath() {
                if (pathIndex >= possiblePaths.length) {
                    console.error('[Test] All paths failed');
                    const pdfContainer = document.getElementById('pdfPagesContainer');
                    if (pdfContainer) {
                        pdfContainer.innerHTML = '<div class="pdf-error">Failed to load PDF from any path</div>';
                    }
                    return;
                }
                
                const pdfUrl = possiblePaths[pathIndex];
                console.log(`[Test] Trying path ${pathIndex + 1}/${possiblePaths.length}: ${pdfUrl}`);
                
                const pdfContainer = document.getElementById('pdfPagesContainer');
                if (!pdfContainer) {
                    console.error('[Test] pdfPagesContainer not found');
                    return;
                }
                
                // Use the existing loadPDF function from pdf.js
                if (typeof window.loadPDF === 'function') {
                    try {
                        // Try to load the PDF
                        const result = window.loadPDF(pdfUrl);
                        
                        // Handle both Promise and direct return cases
                        if (result && typeof result.then === 'function') {
                            // It's a Promise
                            result.then(function(success) {
                                if (success) {
                                    console.log(`[Test] Successfully loaded PDF from path: ${pdfUrl}`);
                                } else {
                                    console.error(`[Test] loadPDF returned false for path ${pdfUrl}`);
                                    pathIndex++;
                                    tryNextPath();
                                }
                            }).catch(function(error) {
                                console.error(`[Test] Error loading PDF from path ${pdfUrl}:`, error);
                                pathIndex++;
                                tryNextPath();
                            });
                        } else if (result === true) {
                            // Direct true return
                            console.log(`[Test] Successfully loaded PDF from path: ${pdfUrl}`);
                        } else {
                            // Failed or unknown return type
                            console.error(`[Test] loadPDF failed for path ${pdfUrl}, returned:`, result);
                            pathIndex++;
                            tryNextPath();
                        }
                    } catch (error) {
                        console.error(`[Test] Error calling loadPDF for path ${pdfUrl}:`, error);
                        pathIndex++;
                        tryNextPath();
                    }
                } else {
                    // Direct fallback - create our own basic PDF loader
                    console.error('[Test] loadPDF function not found, using fallback');
                    pdfContainer.innerHTML = '<div class="pdf-loading"><i class="fas fa-spinner"></i> Loading PDF (fallback)...</div>';
                    
                    if (typeof pdfjsLib !== 'undefined') {
                        const loadingTask = pdfjsLib.getDocument(pdfUrl);
                        loadingTask.promise.then(function(pdf) {
                            console.log(`[Test] PDF loaded successfully via fallback from path: ${pdfUrl}`);
                            
                            // Clear container
                            pdfContainer.innerHTML = '';
                            
                            // Use our fallback renderPage function
                            const renderPromises = [];
                            for (let i = 1; i <= pdf.numPages; i++) {
                                renderPromises.push(fallbackRenderPage(pdf, i, pdfContainer));
                            }
                            
                            // Wait for all pages to be rendered
                            Promise.all(renderPromises)
                                .then(function(pageDivs) {
                                    console.log(`[Test] All ${pageDivs.length} pages rendered via fallback`);
                                })
                                .catch(function(error) {
                                    console.error('[Test] Error rendering pages via fallback:', error);
                                });
                        }).catch(function(error) {
                            console.error(`[Test] Error loading PDF via fallback: ${pdfUrl}:`, error);
                            pdfContainer.innerHTML = `<div class="pdf-error">Error: ${error.message}</div>`;
                        });
                    } else {
                        console.error('[Test] PDF.js library not available for fallback');
                        pdfContainer.innerHTML = '<div class="pdf-error">PDF.js library not available</div>';
                    }
                }
            }
            
            // Start trying paths
            tryNextPath();
        }
    </script>
    
    <!-- Fallback script for direct modal control -->
    <script>
        // Direct modal control functions
        function directOpenModal(modalId) {
            console.log('Opening modal:', modalId);
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'flex';
                modal.style.opacity = '1';
                modal.style.visibility = 'visible';
                modal.classList.add('active');
                
                // If it's the settings modal, initialize tabs and load settings
                if (modalId === 'settingsModal') {
                    initSettingsTabs();
                    loadSettingsPreservingWorkspace();
                }
                
                console.log('Modal opened:', modalId);
            } else {
                console.error('Modal not found:', modalId);
            }
        }
        
        // Function to close a modal directly
        function directCloseModal(modalId) {
            console.log('Closing modal:', modalId);
            const modal = document.getElementById(modalId);
            if (modal) {
                // Simply hide the modal
                modal.style.display = 'none';
                modal.style.opacity = '0';
                modal.style.visibility = 'hidden';
                modal.classList.remove('active');
                
                // Force body to be scrollable again if it was locked
                document.body.style.overflow = '';
                
                console.log('Modal closed:', modalId);
            } else {
                console.error('Modal not found:', modalId);
            }
        }
        
        // File tree functionality
        // Initialize with empty file system
        const fileSystem = {
            id: 'root',
            type: 'folder',
            children: []
        };
        
        // Export fileSystem to window object for debugging
        window.fileSystem = fileSystem;
        
        // Track expanded folders
        const expandedFolders = new Set(['root']);
        
        // Track selected item
        let selectedItemId = null;
        
        // Chat functionality
        // Array to store chat messages
        const chatHistory = [];
        
        // Message types
        const MESSAGE_TYPE = {
            USER: 'user',
            ASSISTANT: 'assistant'
        };
        
        // Function to send a chat message
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const chatMessages = document.getElementById('chatMessages');
            const chatInputContainer = document.querySelector('.chat-input-container');
            
            // Check if input is not empty
            if (chatInput && chatInput.value.trim() !== '') {
                const messageText = chatInput.value.trim();
                
                // Create message object
                const userMessage = {
                    type: MESSAGE_TYPE.USER,
                    text: messageText,
                    timestamp: new Date().toISOString()
                };
                
                // Add to chat history
                chatHistory.push(userMessage);
                console.log('Added user message to history:', userMessage);
                
                // Create and append user message element
                const userMessageElement = document.createElement('div');
                userMessageElement.className = 'message user';
                userMessageElement.innerHTML = `
                    <div class="message-content">
                        ${messageText}
                    </div>
                `;
                chatMessages.appendChild(userMessageElement);
                
                // Clear input and reset heights
                chatInput.value = '';
                chatInput.style.height = 'auto';
                chatInputContainer.style.height = '100px';
                
                // Scroll to bottom
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Simulate assistant response
                setTimeout(() => {
                    // Create response text (in a real app, this would come from an API)
                    const responseText = `I received your message: "${messageText}". This is a simulated response.`;
                    
                    // Create message object
                    const assistantMessage = {
                        type: MESSAGE_TYPE.ASSISTANT,
                        text: responseText,
                        timestamp: new Date().toISOString()
                    };
                    
                    // Add to chat history
                    chatHistory.push(assistantMessage);
                    console.log('Added assistant message to history:', assistantMessage);
                    
                    // Create and append assistant message element
                    const assistantMessageElement = document.createElement('div');
                    assistantMessageElement.className = 'message assistant';
                    assistantMessageElement.innerHTML = `
                        <div class="message-content">
                            ${responseText}
                        </div>
                    `;
                    chatMessages.appendChild(assistantMessageElement);
                    
                    // Scroll to bottom
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 1000);
                
                // Return the user message for potential further processing
                return userMessage;
            }
            
            return null;
        }
        
        // Function to get chat history
        function getChatHistory() {
            return [...chatHistory]; // Return a copy to prevent direct modification
        }
        
        // Function to clear chat history
        function clearChatHistory() {
            chatHistory.length = 0;
            const chatMessages = document.getElementById('chatMessages');
            
            // Keep only the initial greeting message
            if (chatMessages) {
                chatMessages.innerHTML = `
                    <div class="message assistant">
                        <div class="message-content">
                            Hello! I'm here to help you analyze your documents. What would you like to know?
                        </div>
                    </div>
                `;
            }
            
            console.log('Chat history cleared');
        }
        
        // Initialize settings tabs
        function initSettingsTabs() {
            console.log('Initializing settings tabs');
            const settingsTabs = document.querySelectorAll('.settings-sidebar li');
            
            if (settingsTabs.length > 0) {
                console.log(`Found ${settingsTabs.length} settings tabs`);
                
                // Add click event to each tab
                settingsTabs.forEach(tab => {
                    tab.addEventListener('click', function() {
                        console.log(`Tab clicked: ${this.getAttribute('data-setting')}`);
                        
                        // Remove active class from all tabs
                        settingsTabs.forEach(t => t.classList.remove('active'));
                        
                        // Add active class to clicked tab
                        this.classList.add('active');
                        
                        // Hide all panels
                        document.querySelectorAll('.settings-panel').forEach(panel => {
                            panel.style.display = 'none';
                        });
                        
                        // Show the selected panel
                        const panelId = this.getAttribute('data-setting') + '-panel';
                        const panel = document.getElementById(panelId);
                        if (panel) {
                            console.log(`Showing panel: ${panelId}`);
                            panel.style.display = 'block';
                        } else {
                            console.error(`Panel not found: ${panelId}`);
                        }
                    });
                });
                
                // Initialize with the first tab active
                const activeTab = document.querySelector('.settings-sidebar li.active') || settingsTabs[0];
                if (activeTab) {
                    console.log(`Setting initial active tab: ${activeTab.getAttribute('data-setting')}`);
                    const panelId = activeTab.getAttribute('data-setting') + '-panel';
                    const panel = document.getElementById(panelId);
                    if (panel) {
                        panel.style.display = 'block';
                    }
                }
            } else {
                console.error('No settings tabs found');
            }
        }
        
        // Load saved settings
        function loadSettingsPreservingWorkspace() {
            // Remember current workspace path
            const workspacePath = document.getElementById('workspacePath');
            const currentPath = workspacePath ? workspacePath.value : '';
            
            // Load other settings
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                const theme = localStorage.getItem('theme') || 'dark';
                themeToggle.checked = theme === 'dark';
                document.documentElement.setAttribute('data-theme', theme);
            }
            
            const fontSize = document.getElementById('fontSize');
            if (fontSize) {
                const savedFontSize = localStorage.getItem('fontSize') || '16';
                fontSize.value = savedFontSize;
                document.documentElement.style.fontSize = savedFontSize + 'px';
            }
            
            const defaultZoom = document.getElementById('defaultZoom');
            if (defaultZoom) {
                const savedZoom = localStorage.getItem('defaultZoom') || '1';
                defaultZoom.value = savedZoom;
            }
            
            const smoothScroll = document.getElementById('smoothScroll');
            if (smoothScroll) {
                const savedSmoothScroll = localStorage.getItem('smoothScroll');
                smoothScroll.checked = savedSmoothScroll === 'true';
            }
            
            // Restore workspace path
            if (workspacePath && currentPath) {
                workspacePath.value = currentPath;
            }
        }
        
        // Function to save settings
        function saveSettings() {
            console.log('Saving settings');
            
            // Save theme setting
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                localStorage.setItem('theme', themeToggle.checked ? 'dark' : 'light');
            }
            
            // Save font size setting
            const fontSize = document.getElementById('fontSize');
            if (fontSize) {
                localStorage.setItem('fontSize', fontSize.value);
            }
            
            // Save default zoom setting
            const defaultZoom = document.getElementById('defaultZoom');
            if (defaultZoom) {
                localStorage.setItem('defaultZoom', defaultZoom.value);
            }
            
            // Save smooth scroll setting
            const smoothScroll = document.getElementById('smoothScroll');
            if (smoothScroll) {
                localStorage.setItem('smoothScroll', smoothScroll.checked);
            }
            
            // Check workspace folder path
            const workspacePath = document.getElementById('workspacePath');
            if (workspacePath && !workspacePath.value.trim()) {
                // Clear the saved path if input is empty
                localStorage.removeItem('workspaceFolderPath');
                // Reset file system and show empty state
                if (typeof initializeFileSystem === 'function') {
                    initializeFileSystem();
                }
            }
            
            // Close the modal with enhanced close function
                directCloseModal('settingsModal');
        }

        // Local file workspace functionality
        
        // Function to handle folder selection with cross-browser support
        async function selectWorkspaceFolder() {
            try {
                // Try modern File System Access API first (Chrome, Edge, etc.)
                if (typeof window.showDirectoryPicker === 'function') {
                    try {
                        // Show directory picker
                        const directoryHandle = await window.showDirectoryPicker();
                        
                        // Save folder path
                        const workspacePath = document.getElementById('workspacePath');
                        if (workspacePath) {
                            workspacePath.value = directoryHandle.name;
                            localStorage.setItem('workspaceFolderPath', directoryHandle.name);
                            
                            // Store handle for current session
                            window.workspaceFolderHandle = directoryHandle;
                            
                            // Update file system with files from this folder
                            await updateFileSystemFromLocalFolder(directoryHandle);
                        }
                    } catch (error) {
                        console.error('Error with directory picker:', error);
                        if (error.name === 'AbortError') {
                            console.log('User cancelled folder selection');
                            // Only clear if no path is already set
                            const savedPath = localStorage.getItem('workspaceFolderPath');
                            if (!savedPath) {
                                // Keep showing empty state
                                ensureEmptyFileTree();
                            }
                        } else {
                            // If error is not user cancellation, try fallback
                            useFallbackFolderSelection();
                        }
                    }
                } else {
                    // Browser doesn't support File System Access API (Firefox, Safari, etc.)
                    console.log('Browser does not support File System Access API, using fallback method');
                    useFallbackFolderSelection();
                }
            } catch (error) {
                console.error('Error in folder selection:', error);
                useFallbackFolderSelection();
            }
        }
        
        // Helper function to ensure file tree is empty
        function ensureEmptyFileTree() {
            console.log('Ensuring file tree is empty');
            
            // Reset file system
            window.fileSystem = {
                id: 'root',
                type: 'folder',
                children: []
            };
            
            // Reset expandedFolders
            if (window.expandedFolders) {
                window.expandedFolders.clear();
                window.expandedFolders.add('root');
            }
            
            // Reset selected item
            window.selectedItemId = null;
            
            // Render empty file tree
            if (typeof window.renderFileTree === 'function') {
                window.renderFileTree();
            } else {
                // If renderFileTree isn't available yet, empty the file tree element directly
                const fileTreeElement = document.getElementById('fileTree');
                if (fileTreeElement) {
                    fileTreeElement.innerHTML = '';
                }
            }
            
            // Show empty workspace message
            showEmptyWorkspaceMessage();
        }
        
        // Fallback folder selection for Firefox, Safari, and other browsers
        function useFallbackFolderSelection() {
            // Create a hidden file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            // Try different directory attributes for maximum compatibility
            fileInput.setAttribute('webkitdirectory', '');
            fileInput.setAttribute('directory', '');
            fileInput.setAttribute('mozdirectory', '');
            fileInput.setAttribute('multiple', '');
            
            // Handle file selection
            fileInput.addEventListener('change', function(e) {
                if (this.files && this.files.length > 0) {
                    // Get the folder name from the first file's path
                    const firstFile = this.files[0];
                    let folderName = 'Unknown Folder';
                    
                    // Different browsers provide different path information
                    if (firstFile.webkitRelativePath) {
                        folderName = firstFile.webkitRelativePath.split('/')[0];
                    } else if (firstFile.name) {
                        // Try to extract folder name from file path if available
                        const pathMatch = firstFile.name.match(/([^\/\\]+)[\\/][^\/\\]+$/);
                        if (pathMatch) {
                            folderName = pathMatch[1];
                        }
                    }
                    
                    // Update UI with folder name
                    const workspacePath = document.getElementById('workspacePath');
                    if (workspacePath) {
                        workspacePath.value = folderName;
                        localStorage.setItem('workspaceFolderPath', folderName);
                    }
                    
                    // Process all selected files
                    processFilesFromInput(this.files);
                }
            });
            
            // Trigger the file input dialog
            fileInput.click();
        }
        
        // Process files from the file input element (fallback method)
        function processFilesFromInput(files) {
            try {
                if (!files || files.length === 0) {
                    console.log('No files selected, showing empty state');
                    // Clear file system
                    window.fileSystem = {
                        id: 'root',
                        type: 'folder',
                        children: []
                    };
                    
                    // Render empty file tree
            renderFileTree();
            
                    // Show empty workspace message
                    showEmptyWorkspaceMessage();
                    return;
                }
                
                // Create new file system structure
                const newFileSystem = {
                    id: 'root',
                    type: 'folder',
                    children: []
                };
                
                // Create a map to track folders
                const folderMap = new Map();
                folderMap.set('root', newFileSystem);
                
                // Process each file
                Array.from(files).forEach(file => {
                    // Get the path parts
                    const pathParts = file.webkitRelativePath ? file.webkitRelativePath.split('/') : ['root', file.name];
                    
                    // Skip the first part (base folder name)
                    let currentPath = '';
                    let parentFolderId = 'root';
                    
                    // Create folder structure
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        const folderName = pathParts[i];
                        currentPath += '/' + folderName;
                        
                        // Skip root folder (already exists)
                        if (i === 0) continue;
                        
                        // Create folder if it doesn't exist
                        if (!folderMap.has(currentPath)) {
                            const folderId = generateUniqueId();
                            const newFolder = {
                                id: folderId,
                                name: folderName,
                                type: 'folder',
                                children: []
                            };
                            
                            // Add to parent folder
                            const parentFolder = folderMap.get(parentFolderId);
                            parentFolder.children.push(newFolder);
                            
                            // Add to folder map
                            folderMap.set(currentPath, newFolder);
                        }
                        
                        parentFolderId = currentPath;
                    }
                    
                    // Process file
                    const fileName = pathParts[pathParts.length - 1];
                    
                    // Determine file type
                    let fileType = 'unknown';
                    if (fileName.toLowerCase().endsWith('.pdf')) {
                        fileType = 'pdf';
                    } else if (/\.(jpe?g|png|gif|bmp|webp)$/i.test(fileName)) {
                        fileType = 'image';
                    } else if (/\.(md|markdown)$/i.test(fileName)) {
                        fileType = 'markdown';
                    } else if (/\.(docx?|xlsx?|pptx?|txt|json|csv)$/i.test(fileName)) {
                        fileType = 'doc';
                    }
                    
                    // Create file object
                    const fileObj = {
                        id: generateUniqueId(),
                        name: fileName,
                        type: 'file',
                        fileType: fileType,
                        file: file,
                        lastModified: file.lastModified,
                        size: file.size
                    };
                    
                    // Add to parent folder
                    const parentFolder = folderMap.get(parentFolderId);
                    parentFolder.children.push(fileObj);
                });
                
                // Update the global file system
                fileSystem.children = newFileSystem.children;
                
                // Clear selected item
                selectedItemId = null;
                
                // Re-render the file tree - make sure to use the properly scoped function
                if (typeof window.renderFileTree === 'function') {
                    window.renderFileTree();
                } else if (typeof renderFileTree === 'function') {
                    renderFileTree();
                } else {
                    console.error('renderFileTree function not found');
                    // Fallback to reloading the page
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                }
                
                // Hide any empty workspace message
                hideEmptyWorkspaceMessage();
                
                console.log('File system updated from input files:', fileSystem);
            } catch (error) {
                console.error('Error processing files from input:', error);
                alert('Error reading workspace folder: ' + error.message);
                
                // Close settings modal in case of error
                directCloseModal('settingsModal');
            }
        }
        
        // Function to get file content for display (supports both modern and fallback methods)
        async function getFileContent(fileItem) {
            if (!fileItem) {
                console.error('Invalid file item');
                return null;
            }
            
            try {
                let file = null;
                
                // Modern API method (using fileHandle)
                if (fileItem.fileHandle) {
                    file = await fileItem.fileHandle.getFile();
                } 
                // Fallback method (using direct file reference)
                else if (fileItem.file) {
                    file = fileItem.file;
                } else {
                    console.error('File item has no file reference');
                    return null;
                }
                
                // For PDFs, create a blob URL
                if (fileItem.fileType === 'pdf') {
                    const blobURL = URL.createObjectURL(file);
                    return { url: blobURL, type: 'pdf' };
                }
                
                // For other file types, return appropriate data
                return { file, type: fileItem.fileType };
            } catch (error) {
                console.error('Error getting file content:', error);
                return null;
            }
        }

        // Function to update file system from local folder (using File System Access API)
        async function updateFileSystemFromLocalFolder(directoryHandle) {
            try {
                // If directoryHandle is a string (from localStorage), try to recover the actual handle
                if (typeof directoryHandle === 'string') {
                    if (window.workspaceFolderHandle) {
                        directoryHandle = window.workspaceFolderHandle;
            } else {
                        // We don't have a valid handle, show the empty state
                        fileSystem.children = [];
                        
                        // Make sure to use the properly scoped function
                        if (typeof window.renderFileTree === 'function') {
                            window.renderFileTree();
                        } else if (typeof renderFileTree === 'function') {
                            renderFileTree();
                        } else {
                            console.error('renderFileTree function not found');
                            // Fallback to reloading the page
                            setTimeout(() => {
                                location.reload();
                            }, 1000);
                        }
                        
                        showEmptyWorkspaceMessage();
                        return;
                    }
                }
                
                // Clear the existing file system
                const newFileSystem = {
                    id: 'root',
                    type: 'folder',
                    children: []
                };
                
                // Process the directory recursively
                await processDirectory(directoryHandle, newFileSystem.children);
                
                // Update the global file system
                fileSystem.children = newFileSystem.children;
                
                // Clear selected item
                selectedItemId = null;
                
                // Re-render the file tree - make sure to use the properly scoped function
                if (typeof window.renderFileTree === 'function') {
                    window.renderFileTree();
                } else if (typeof renderFileTree === 'function') {
                    renderFileTree();
                } else {
                    console.error('renderFileTree function not found');
                    // Fallback to reloading the page
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                }
                
                // Hide any empty workspace message
                hideEmptyWorkspaceMessage();
                
                console.log('File system updated from local folder:', fileSystem);
            } catch (error) {
                console.error('Error updating file system:', error);
                alert('Error reading workspace folder: ' + error.message);
                
                // Close settings modal in case of error
                directCloseModal('settingsModal');
            }
        }
        
        // Function to process a directory recursively
        async function processDirectory(directoryHandle, children) {
            // Process files and subfolders
            for await (const entry of directoryHandle.values()) {
                if (entry.kind === 'file') {
                    // Process file
                    const file = await entry.getFile();
                    
                    // Determine file type
                    let fileType = 'unknown';
                    if (file.name.toLowerCase().endsWith('.pdf')) {
                        fileType = 'pdf';
                    } else if (/\.(jpe?g|png|gif|bmp|webp)$/i.test(file.name)) {
                        fileType = 'image';
                    } else if (/\.(md|markdown)$/i.test(file.name)) {
                        fileType = 'markdown';
                    } else if (/\.(docx?|xlsx?|pptx?|txt|json|csv)$/i.test(file.name)) {
                        fileType = 'doc';
                    }
                    
                    // Add file to children
                    children.push({
                        id: generateUniqueId(),
                        name: file.name,
                        type: 'file',
                        fileType: fileType,
                        fileHandle: entry,
                        lastModified: file.lastModified,
                        size: file.size
                    });
                } else if (entry.kind === 'directory') {
                    // Process subfolder
                    const subfolderChildren = [];
                    const subfolderId = generateUniqueId();
                    
                    // Add subfolder to children first
                    children.push({
                        id: subfolderId,
                        name: entry.name,
                        type: 'folder',
                        children: subfolderChildren,
                        folderHandle: entry
                    });
                    
                    // Recursively process subfolder
                    await processDirectory(entry, subfolderChildren);
                }
            }
        }
        
        // Generate a unique ID for files and folders
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }
        
        // Function to show empty workspace message
        function showEmptyWorkspaceMessage() {
            console.log('Showing empty workspace message');
            
            // Find or create PDF viewer
            const pdfViewer = document.getElementById('pdfViewer');
            if (!pdfViewer) {
                console.error('PDF viewer element not found');
                return;
            }
            
            // Find or create PDF container
            let pdfContainer = document.getElementById('pdfContainer');
            if (!pdfContainer) {
                console.log('Creating new PDF container');
                pdfContainer = document.createElement('div');
                pdfContainer.id = 'pdfContainer';
                pdfContainer.className = 'pdf-container';
                pdfViewer.appendChild(pdfContainer);
            } else {
                // Clear existing content
                pdfContainer.innerHTML = '';
            }
            
            // Create and add empty workspace message
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-workspace-message';
            emptyMessage.innerHTML = `
                <i class="fas fa-folder-open"></i>
                <h3>No Workspace Folder Selected</h3>
                <p>Select a local folder to use as your workspace in Settings > PDF Viewer.</p>
                <button id="selectWorkspaceFolderBtn" class="modal-btn modal-btn-primary">
                    <i class="fas fa-folder"></i> Select Folder
                </button>
            `;
            pdfContainer.appendChild(emptyMessage);
            
            // Add click handler to the button
            const selectBtn = document.getElementById('selectWorkspaceFolderBtn');
            if (selectBtn) {
                selectBtn.addEventListener('click', function() {
                    // Open settings modal
                    directOpenModal('settingsModal');
                    
                    // Switch to PDF viewer tab
                    const pdfViewerTab = document.querySelector('.settings-sidebar li[data-setting="pdf-viewer"]');
                    if (pdfViewerTab) {
                        pdfViewerTab.click();
                    }
                });
            }
        }
        
        // Function to hide empty workspace message
        function hideEmptyWorkspaceMessage() {
            const emptyMessage = document.querySelector('.empty-workspace-message');
            if (emptyMessage) {
                emptyMessage.remove();
            }
        }
        
        // Function to select an item in the file tree
        function selectItem(itemId) {
            console.log(`[FileTree] selectItem called with itemId: ${itemId}`);
            
            // Find the item in the file system
            const findItem = (folder) => {
                if (folder.id === itemId) {
                    return folder;
                }
                
                if (folder.children) {
                    for (const child of folder.children) {
                        const found = findItem(child);
                        if (found) return found;
                    }
                }
                
                return null;
            };
            
            const item = findItem(fileSystem);
            
            if (!item) {
                console.error(`[FileTree] Item with id ${itemId} not found in file system`);
                return;
            }
            
            console.log(`[FileTree] Found item:`, item);
            
            // Only select the item if it's a file
            if (item && item.type === 'file') {
                selectedItemId = itemId;
                console.log(`[FileTree] Selected item ID set to: ${selectedItemId}`);
                
                // Remove selected class from all items
                document.querySelectorAll('.tree-item-content').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Add selected class to selected item
                const selectedItem = document.querySelector(`.tree-item[data-id="${itemId}"] > .tree-item-content`);
                if (selectedItem) {
                    selectedItem.classList.add('selected');
                }
                
                console.log(`[FileTree] Selected item: ${itemId}`);
                
                // Hide both containers initially
                const pdfPagesContainer = document.getElementById('pdfPagesContainer');
                const markdownSection = document.querySelector('.markdown-section');
                
                if (pdfPagesContainer) pdfPagesContainer.style.display = 'none';
                if (markdownSection) markdownSection.style.display = 'none';
                
                // Load the file based on its type
                if (item.fileType === 'pdf') {
                    console.log(`[FileTree] Item is a PDF file, loading content`);
                    
                    // Show PDF container
                    if (pdfPagesContainer) {
                        pdfPagesContainer.style.display = 'block';
                        // Clear previous content and show loading indicator
                        pdfPagesContainer.innerHTML = '<div class="pdf-loading"><i class="fas fa-spinner"></i> Loading PDF...</div>';
                    }
                    
                    // Get the file content
                    if (item.file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const arrayBuffer = e.target.result;
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const url = URL.createObjectURL(blob);
                            
                            // First ensure the PDF functions are available
                            ensurePDFFunctionsAvailable();
                            
                            // Use the existing PDF.js function
                            if (typeof window.loadPDF === 'function') {
                                try {
                                    // Try to load the PDF
                                    const result = window.loadPDF(url);
                                    
                                    // Handle both Promise and direct return cases
                                    if (result && typeof result.then === 'function') {
                                        // It's a Promise
                                        result.then(function(success) {
                                            if (success) {
                                                console.log(`[FileTree] Successfully loaded PDF from file: ${item.name}`);
                                            }
                                        }).catch(function(error) {
                                            console.error('[FileTree] Error loading PDF:', error);
                                        });
                                    } else if (result === true) {
                                        // Direct true return
                                        console.log(`[FileTree] Successfully loaded PDF from file: ${item.name}`);
                                    } else {
                                        // Failed or unknown return type
                                        console.error(`[FileTree] loadPDF failed for file: ${item.name}, returned:`, result);
                                    }
                                } catch (error) {
                                    console.error(`[FileTree] Error calling loadPDF for file: ${item.name}:`, error);
                                }
                            } else {
                                // Direct fallback - create our own basic PDF loader
                                console.error('[FileTree] loadPDF function not available, using fallback');
                                pdfPagesContainer.innerHTML = '<div class="pdf-loading"><i class="fas fa-spinner"></i> Loading PDF (fallback)...</div>';
                                
                                if (typeof pdfjsLib !== 'undefined') {
                                    const loadingTask = pdfjsLib.getDocument(url);
                                    loadingTask.promise.then(function(pdf) {
                                        console.log(`[FileTree] PDF loaded successfully via fallback: ${item.name} with ${pdf.numPages} pages`);
                                        
                                        // Clear container
                                        pdfPagesContainer.innerHTML = '';
                                        
                                        // Use our fallback renderPage function
                                        const renderPromises = [];
                                        for (let i = 1; i <= pdf.numPages; i++) {
                                            renderPromises.push(fallbackRenderPage(pdf, i, pdfPagesContainer));
                                        }
                                        
                                        // Wait for all pages to be rendered
                                        Promise.all(renderPromises)
                                            .then(function(pageDivs) {
                                                console.log(`[FileTree] All ${pageDivs.length} pages rendered via fallback`);
                                            })
                                            .catch(function(error) {
                                                console.error('[FileTree] Error rendering pages via fallback:', error);
                                            });
                                    }).catch(function(error) {
                                        console.error(`[FileTree] Error loading PDF via fallback: ${item.name}:`, error);
                                        pdfPagesContainer.innerHTML = `<div class="pdf-error">Error: ${error.message}</div>`;
                                    });
                                } else {
                                    console.error('[FileTree] PDF.js library not available for fallback');
                                    pdfPagesContainer.innerHTML = '<div class="pdf-error">PDF.js library not available</div>';
                                }
                            }
                        };
                        reader.readAsArrayBuffer(item.file);
                    }
                } else if (item.fileType === 'markdown') {
                    console.log(`[FileTree] Item is a markdown file, loading content`);
                    
                    // Show markdown section
                    const markdownSection = document.querySelector('.markdown-section');
                    if (markdownSection) {
                        markdownSection.style.display = 'flex';
                    }
                    
                    // Update the title
                    const markdownTitle = document.getElementById('markdownTitle');
                    if (markdownTitle) {
                        markdownTitle.textContent = item.name;
                    }
                    
                    // Handle markdown file through our handler
                    if (typeof handleMarkdownFileSelection === 'function') {
                        handleMarkdownFileSelection(item);
                    } else if (typeof window.handleMarkdownFileSelection === 'function') {
                        // Try global function if local one is not available
                        window.handleMarkdownFileSelection(item);
                    } else {
                        console.error('[FileTree] Markdown handler function not available');
                        
                        // Fallback to basic display
                        if (item.file) {
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                const content = e.target.result;
                                const markdownContainer = document.getElementById('markdownContainer');
                                if (markdownContainer) {
                                    if (typeof marked !== 'undefined') {
                                        markdownContainer.innerHTML = marked.parse(content);
                                    } else {
                                        // Super basic fallback
                                        markdownContainer.innerHTML = `<pre>${content}</pre>`;
                                    }
                                }
                            };
                            reader.onerror = function(e) {
                                console.error('[FileTree] Error reading markdown file:', e);
                            };
                            reader.readAsText(item.file);
                        }
                    }
                }
            }
        }

        // Global search variables
        let currentSearchResults = [];
        let currentResultIndex = -1;

        function clearSearchHighlights() {
            document.querySelectorAll('.search-highlight').forEach(highlight => highlight.remove());
            currentSearchResults = [];
            currentResultIndex = -1;
        }

        function highlightSearchResults(searchTerm) {
            if (!searchTerm) return;
            
            clearSearchHighlights();
            
            const textLayers = document.querySelectorAll('.textLayer');
            const searchRegex = new RegExp(searchTerm, 'gi');
            let totalMatches = 0;
            
            textLayers.forEach(textLayer => {
                const textElements = textLayer.querySelectorAll('span');
                const textLayerRect = textLayer.getBoundingClientRect();
                
                textElements.forEach(span => {
                    const text = span.textContent;
                    let match;
                    
                    // Get the span's computed style for accurate measurements
                    const spanStyle = window.getComputedStyle(span);
                    const spanRect = span.getBoundingClientRect();
                    
                    while ((match = searchRegex.exec(text)) !== null) {
                        const highlight = document.createElement('div');
                        highlight.className = 'search-highlight';
                        
                        // Calculate the position of the match within the span
                        const preMatchText = text.substring(0, match.index);
                        const matchText = match[0];
                        
                        // Create temporary span for measurements
                        const tempSpan = document.createElement('span');
                        Object.assign(tempSpan.style, {
                            font: spanStyle.font,
                            fontSize: spanStyle.fontSize,
                            letterSpacing: spanStyle.letterSpacing,
                            position: 'absolute',
                            visibility: 'hidden',
                            whiteSpace: 'pre',
                            display: 'inline-block',
                            transform: 'none'
                        });
                        
                        // Measure pre-match width
                        tempSpan.textContent = preMatchText;
                        document.body.appendChild(tempSpan);
                        const preMatchWidth = tempSpan.getBoundingClientRect().width;
                        
                        // Measure match width
                        tempSpan.textContent = matchText;
                        const matchWidth = tempSpan.getBoundingClientRect().width;
                        tempSpan.remove();
                        
                        // Get the transform matrix from the span
                        const transform = spanStyle.transform;
                        const matrix = new DOMMatrix(transform);
                        const scale = matrix.a; // Horizontal scale factor
                        
                        // Calculate position relative to text layer, accounting for transform
                        const scaledPreMatchWidth = preMatchWidth * scale;
                        const scaledMatchWidth = matchWidth * scale;
                        const left = spanRect.left - textLayerRect.left + scaledPreMatchWidth;
                        const top = spanRect.top - textLayerRect.top;
                        
                        // Position and size the highlight
                        highlight.style.left = `${left}px`;
                        highlight.style.top = `${top}px`;
                        highlight.style.width = `${scaledMatchWidth}px`;
                        highlight.style.height = `${spanRect.height}px`;
                        
                        // Apply the same transform as the text span
                        highlight.style.transform = transform;
                        highlight.style.transformOrigin = 'left top';
                        
                        textLayer.appendChild(highlight);
                        currentSearchResults.push({
                            element: highlight,
                            page: textLayer.closest('.pdf-page')
                        });
                        totalMatches++;
                    }
                });
            });
            
            if (currentSearchResults.length > 0) {
                currentResultIndex = 0;
                const current = currentSearchResults[0];
                current.element.classList.add('current');
                current.page.scrollIntoView({ behavior: 'smooth', block: 'center' });
                updateSearchCount();
            }
            
            console.log(`Found ${totalMatches} matches for "${searchTerm}"`);
        }

        function navigateSearchResults(direction) {
            if (currentSearchResults.length === 0) return;
            
            currentSearchResults[currentResultIndex].element.classList.remove('current');
            
            if (direction === 'next') {
                currentResultIndex = (currentResultIndex + 1) % currentSearchResults.length;
                    } else {
                currentResultIndex = (currentResultIndex - 1 + currentSearchResults.length) % currentSearchResults.length;
            }
            
            const current = currentSearchResults[currentResultIndex];
            current.element.classList.add('current');
            current.page.scrollIntoView({ behavior: 'smooth', block: 'center' });
            updateSearchCount();
        }

        // Initialize search controls - Updated
        document.addEventListener('DOMContentLoaded', function() {
            console.log('[Search] Initializing search controls');
            
            const searchIcon = document.getElementById('searchIcon');
            const searchModal = document.getElementById('searchModal');
            const closeSearchModal = document.getElementById('closeSearchModal');
            const searchInput = document.getElementById('pdfSearchInput');
            const prevResult = document.getElementById('prevResult');
            const nextResult = document.getElementById('nextResult');
            const searchCount = document.getElementById('searchCount');
            
            console.log('[Search] Elements found:', {
                searchIcon: !!searchIcon,
                searchModal: !!searchModal,
                closeSearchModal: !!closeSearchModal,
                searchInput: !!searchInput,
                prevResult: !!prevResult,
                nextResult: !!nextResult,
                searchCount: !!searchCount
            });

            // Handle Ctrl+F to open search modal
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault(); // Prevent browser's default search
                    if (searchModal && searchInput) {
                        searchModal.style.display = 'block';
                        searchModal.style.opacity = '1';
                        searchModal.style.visibility = 'visible';
                        searchModal.classList.add('active');
                        searchInput.value = ''; // Clear previous search
                        searchInput.focus();
                        clearSearchHighlights();
                    }
                }
            });
            
            if (searchIcon && searchModal && closeSearchModal) {
                // Toggle search modal
                searchIcon.addEventListener('click', (e) => {
                    console.log('[Search] Search icon clicked');
                    e.stopPropagation(); // Prevent event from bubbling up
                    searchModal.style.display = 'block';
                    searchModal.style.opacity = '1';
                    searchModal.style.visibility = 'visible';
                    searchModal.classList.add('active');
                    console.log('[Search] Search modal display:', searchModal.style.display);
                    console.log('[Search] Search modal classes:', searchModal.className);
                    
                    if (searchInput) {
                        searchInput.value = ''; // Clear previous search
                        searchInput.focus();
                        clearSearchHighlights();
                    }
                });
                
                // Function to close the modal with animation
                function closeModalWithAnimation() {
                    searchModal.classList.remove('active');
                    // Wait for animation to complete before hiding
                    setTimeout(() => {
                        searchModal.style.display = 'none';
                        searchModal.style.opacity = '0';
                        searchModal.style.visibility = 'hidden';
                        clearSearchHighlights();
                    }, 500); // Match the animation duration
                }
                
                // Updated close button behavior
                closeSearchModal.addEventListener('click', (e) => {
                    console.log('[Search] Close button clicked');
                    e.stopPropagation(); // Prevent event from bubbling up
                    if (searchInput && searchInput.value.trim() !== '') {
                        // If there's text, clear it
                        searchInput.value = '';
                        clearSearchHighlights();
                        updateSearchCount();
                    } else {
                        // If no text, close the modal with animation
                        closeModalWithAnimation();
                    }
                });
                
                // Close modal only on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && searchModal.style.display === 'block') {
                        closeModalWithAnimation();
                    }
                });
            }
            
            if (searchInput) {
                // Search input events
                let debounceTimeout;
                searchInput.addEventListener('input', () => {
                    clearTimeout(debounceTimeout);
                    debounceTimeout = setTimeout(() => {
                        const searchTerm = searchInput.value.trim();
                        if (searchTerm) {
                            highlightSearchResults(searchTerm);
                            updateSearchCount();
                        } else {
                            clearSearchHighlights();
                            updateSearchCount();
                        }
                    }, 300); // Debounce search for better performance
                });
                
                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            navigateSearchResults('prev');
                        } else {
                            navigateSearchResults('next');
                        }
                    } else if (e.key === 'Escape') {
                        closeModalWithAnimation();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        navigateSearchResults('prev');
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        navigateSearchResults('next');
                    }
                });
            }
            
            // Navigation buttons
            if (prevResult && nextResult) {
                prevResult.addEventListener('click', () => navigateSearchResults('prev'));
                nextResult.addEventListener('click', () => navigateSearchResults('next'));
            }
        });

        // Update search count display
        function updateSearchCount() {
            const searchCount = document.getElementById('searchCount');
            const prevResult = document.getElementById('prevResult');
            const nextResult = document.getElementById('nextResult');
            
            if (searchCount) {
                if (currentSearchResults.length === 0) {
                    searchCount.textContent = 'No results';
                    prevResult.disabled = true;
                    nextResult.disabled = true;
                } else {
                    searchCount.textContent = `${currentResultIndex + 1} of ${currentSearchResults.length}`;
                    prevResult.disabled = false;
                    nextResult.disabled = false;
                }
            }
        }
    </script>
    <!-- Initialize zoom controls -->
    <script>
        // Initialize zoom controls
        document.addEventListener('DOMContentLoaded', function() {
            console.log('[Zoom] Initializing zoom controls');
            
            const zoomInBtn = document.getElementById('zoomIn');
            const zoomOutBtn = document.getElementById('zoomOut');
            const zoomLevel = document.getElementById('zoomLevel');
            
            // Get saved zoom level from localStorage or default to 100%
            let currentZoom = parseFloat(localStorage.getItem('pdfZoom')) || 1.0;
            
            // Update zoom level display
            function updateZoomDisplay() {
                if (zoomLevel) {
                    zoomLevel.textContent = `${Math.round(currentZoom * 100)}%`;
                }
            }
            
            // Function to apply zoom to all pages
            function applyZoom(scale) {
                const pdfContainer = document.getElementById('pdfContainer');
                const pdfViewer = document.getElementById('pdfViewer');
                if (!pdfContainer || !pdfViewer) return;

                // Store original dimensions if not already stored
                if (!pdfContainer.dataset.originalWidth) {
                    pdfContainer.dataset.originalWidth = pdfContainer.offsetWidth;
                    pdfContainer.dataset.originalHeight = pdfContainer.offsetHeight;
                }

                // Get the scroll position relative to the content before zoom
                const scrollTop = pdfViewer.scrollTop;
                const scrollLeft = pdfViewer.scrollLeft;
                const viewerHeight = pdfViewer.offsetHeight;
                const viewerWidth = pdfViewer.offsetWidth;
                
                // Calculate the center point of the viewport
                const centerX = scrollLeft + (viewerWidth / 2);
                const centerY = scrollTop + (viewerHeight / 2);
                
                // Calculate the relative position (0-1) of the center point
                const relativeX = centerX / (pdfContainer.offsetWidth);
                const relativeY = centerY / (pdfContainer.offsetHeight);

                // Apply transform to the container
                pdfContainer.style.transform = `scale(${scale})`;
                
                // Calculate new dimensions
                const originalWidth = parseFloat(pdfContainer.dataset.originalWidth);
                const originalHeight = parseFloat(pdfContainer.dataset.originalHeight);
                const scaledWidth = originalWidth * scale;
                const scaledHeight = originalHeight * scale;
                
                // Calculate margins to center the content
                const marginX = Math.max(0, (viewerWidth - scaledWidth) / 2);
                
                // Update container size and centering
                pdfContainer.style.width = `${originalWidth}px`;
                pdfContainer.style.height = `${originalHeight}px`;
                pdfContainer.style.minHeight = `${originalHeight}px`;
                pdfContainer.style.marginLeft = `${marginX}px`;
                
                // Calculate new scroll position to maintain the same center point
                const newScrollLeft = (relativeX * scaledWidth) - (viewerWidth / 2);
                const newScrollTop = (relativeY * scaledHeight) - (viewerHeight / 2);
                
                // Apply new scroll position
                requestAnimationFrame(() => {
                    pdfViewer.scrollTo({
                        left: Math.max(0, newScrollLeft),
                        top: Math.max(0, newScrollTop),
                        behavior: 'instant'
                    });
                });
                
                // Save zoom level to localStorage
                localStorage.setItem('pdfZoom', scale);
                updateZoomDisplay();
                
                // Ensure viewer has proper overflow
                pdfViewer.style.overflowX = scale > 1 ? 'auto' : 'hidden';
                pdfViewer.style.overflowY = 'auto';
            }
            
            // Add click handlers for zoom buttons
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    currentZoom = Math.min(currentZoom + 0.1, 3.0); // Max zoom of 300%
                    applyZoom(currentZoom);
                });
            }
            
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    currentZoom = Math.max(currentZoom - 0.1, 0.2); // Min zoom of 20%
                    applyZoom(currentZoom);
                });
            }

            // Add mouse wheel zoom functionality to zoom level indicator
            if (zoomLevel) {
                zoomLevel.addEventListener('wheel', (e) => {
                    e.preventDefault(); // Prevent page scrolling
                    
                    // Determine zoom direction based on wheel delta
                    const delta = e.deltaY;
                    const zoomStep = 0.05; // Smaller step for smoother zooming
                    
                    if (delta < 0) {
                        // Scrolling up - zoom in
                        currentZoom = Math.min(currentZoom + zoomStep, 3.0);
                    } else {
                        // Scrolling down - zoom out
                        currentZoom = Math.max(currentZoom - zoomStep, 0.2);
                    }
                    
                    applyZoom(currentZoom);
                });
            }
            
            // Initialize zoom display
            updateZoomDisplay();
            
            // Apply saved zoom level on page load
            applyZoom(currentZoom);
        });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Add resize handles to sidebars
        const sidebar = document.querySelector('.sidebar');
        const chatSection = document.querySelector('.chat-section');
        
        // Create and add resize handles
        const leftHandle = document.createElement('div');
        leftHandle.className = 'resize-handle left';
        sidebar.appendChild(leftHandle);
        
        const rightHandle = document.createElement('div');
        rightHandle.className = 'resize-handle right';
        chatSection.appendChild(rightHandle);
        
        // Resize functionality
        function initResize(handle, element, isLeft) {
            let startX, startWidth;
            
            function startResizing(e) {
                startX = e.clientX;
                startWidth = parseInt(getComputedStyle(element).width, 10);
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResizing);
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            }
            
            function resize(e) {
                const diff = e.clientX - startX;
                let newWidth = isLeft ? startWidth + diff : startWidth - diff;
                
                // Apply min and max constraints
                newWidth = Math.max(isLeft ? 150 : 200, Math.min(isLeft ? 500 : 600, newWidth));
                
                element.style.width = `${newWidth}px`;
            }
            
            function stopResizing() {
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResizing);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
            
            handle.addEventListener('mousedown', startResizing);
        }
        
        // Initialize resize handlers
        initResize(leftHandle, sidebar, true);
        initResize(rightHandle, chatSection, false);
    });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const sidebar = document.getElementById('sidebar');
        const fileTreeBtn = document.getElementById('fileTreeBtn');
        const chatBtn = document.getElementById('chatBtn');
        const fileTreePanel = document.getElementById('fileTreePanel');
        const chatPanel = document.getElementById('chatPanel');
        let activeButton = fileTreeBtn;
        let isCollapsed = false;
        let lastWidth = 250;
        let isResizing = false;

        function togglePanel(button, panel) {
            if (activeButton === button && !isCollapsed) {
                lastWidth = parseInt(getComputedStyle(sidebar).width, 10);
                sidebar.classList.add('collapsed');
                isCollapsed = true;
                sidebar.style.width = '48px';
            } else {
                sidebar.classList.remove('collapsed');
                isCollapsed = false;
                sidebar.style.width = `${lastWidth}px`;
                
                activeButton.classList.remove('active');
                document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.remove('active'));
                
                button.classList.add('active');
                panel.classList.add('active');
                activeButton = button;
            }
        }

        fileTreeBtn.addEventListener('click', () => togglePanel(fileTreeBtn, fileTreePanel));
        chatBtn.addEventListener('click', () => togglePanel(chatBtn, chatPanel));

        // Handle resize to collapse sidebar
        const resizeHandle = document.querySelector('.resize-handle.left');
        if (resizeHandle) {
            let startX, startWidth;
            const COLLAPSE_THRESHOLD = 160;

            function preventSelection(e) {
                e.preventDefault();
            }
            
            function startResizing(e) {
                if (e.button !== 0) return; // Only handle left mouse button
                isResizing = true;
                startX = e.clientX;
                startWidth = parseInt(getComputedStyle(sidebar).width, 10);
                
                // Add event listeners
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResizing, { once: true });
                document.addEventListener('selectstart', preventSelection);
                
                // Set cursor and prevent text selection
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                document.body.style.webkitUserSelect = 'none';
                document.body.style.MozUserSelect = 'none';
                
                e.preventDefault();
                e.stopPropagation();
            }
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const width = Math.max(48, Math.min(500, startWidth + (e.clientX - startX)));
                requestAnimationFrame(() => {
                    if (width <= COLLAPSE_THRESHOLD) {
                        sidebar.classList.add('collapsed');
                        isCollapsed = true;
                        sidebar.style.width = '48px';
                    } else {
                        if (isCollapsed) {
                            sidebar.classList.remove('collapsed');
                            isCollapsed = false;
                        }
                        sidebar.style.width = `${width}px`;
                        lastWidth = width;
                    }
                });
            }
            
            function stopResizing() {
                isResizing = false;
                
                // Remove event listeners
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('selectstart', preventSelection);
                
                // Reset cursor and text selection
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                document.body.style.webkitUserSelect = '';
                document.body.style.MozUserSelect = '';
            }
            
            resizeHandle.addEventListener('mousedown', startResizing);
            
            // Add touch support
            resizeHandle.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                startResizing({ 
                    button: 0,
                    clientX: touch.clientX,
                    preventDefault: () => e.preventDefault(),
                    stopPropagation: () => e.stopPropagation()
                });
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;
                const touch = e.touches[0];
                handleResize({ clientX: touch.clientX });
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchend', () => {
                if (isResizing) {
                    stopResizing();
                }
            });
        }
    });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Model selector functionality
        const modelSelectBtn = document.getElementById('modelSelectBtn');
        const modelDropdown = document.getElementById('modelDropdown');
        const modelOptions = document.querySelectorAll('.model-option');

        // Toggle dropdown
        modelSelectBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            modelDropdown.classList.toggle('active');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            modelDropdown.classList.remove('active');
        });

        // Handle model selection
        modelOptions.forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Update active state
                modelOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                
                // Update button text
                modelSelectBtn.innerHTML = `${option.querySelector('span').textContent} <i class="fas fa-chevron-down"></i>`;
                
                // Close dropdown
                modelDropdown.classList.remove('active');
            });
        });

        // Existing chat functionality...
        // ... existing code ...
    });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Add event listeners when DOM is loaded
            console.log('Direct script loaded');
            
            // Add click handler to settings button
            const settingsBtn = document.getElementById('sidebarSettingsBtn');
            if (settingsBtn) {
                console.log('Settings button found in direct script');
                settingsBtn.onclick = function() {
                    console.log('Settings button clicked in direct script');
                    directOpenModal('settingsModal');
                    // Initialize tabs when modal is opened
                    initSettingsTabs();
                    // Load saved settings
                loadSettingsPreservingWorkspace();
                    return false;
                };
            }
            
            // Add click handlers to close buttons
            const closeButtons = document.querySelectorAll('.modal-close');
            closeButtons.forEach(function(btn) {
                btn.onclick = function() {
                    const modalId = this.closest('.modal-overlay').id;
                    directCloseModal(modalId);
                    return false;
                };
            });
            
            // Add event listeners for settings changes
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                themeToggle.addEventListener('change', function() {
                    document.documentElement.setAttribute('data-theme', this.checked ? 'dark' : 'light');
                });
            }
            
            const fontSize = document.getElementById('fontSize');
            if (fontSize) {
                fontSize.addEventListener('change', function() {
                    document.documentElement.style.fontSize = this.value + 'px';
                });
            }
        
        // Add workspace folder selection event listener
        const selectWorkspaceFolderBtn = document.getElementById('selectWorkspaceFolder');
        if (selectWorkspaceFolderBtn) {
            selectWorkspaceFolderBtn.addEventListener('click', function() {
                selectWorkspaceFolder();
            });
        }
        
        // Add save settings button event listener
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        if (saveSettingsBtn) {
            saveSettingsBtn.addEventListener('click', function() {
                saveSettings();
            });
        }
            
            // Add click handler to modal overlay for closing when clicking outside
            const modalOverlays = document.querySelectorAll('.modal-overlay');
            modalOverlays.forEach(function(overlay) {
                overlay.addEventListener('click', function(e) {
                    if (e.target === this) {
                        directCloseModal(this.id);
                    }
                });
            });
            
            // Add event listeners for chat
            const sendButton = document.getElementById('sendMessage');
            if (sendButton) {
                sendButton.addEventListener('click', function() {
                    sendChatMessage();
                });
            }
            
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keydown', function(e) {
                    // Send message on Enter key (but not with Shift+Enter)
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Prevent default to avoid newline
                        sendChatMessage();
                    }
                });
            }
            
            // Initialize file tree
            renderFileTree();
            
        // Check if we have a workspace folder, if not show empty message
        const savedPath = localStorage.getItem('workspaceFolderPath');
        if (!savedPath && !fileSystem.children.length) {
                        showEmptyWorkspaceMessage();
        }
        
            // Add click handlers for file tree action buttons
            const newNoteBtn = document.querySelector('.file-tree-actions .action-btn:nth-child(1)');
            if (newNoteBtn) {
                newNoteBtn.addEventListener('click', function() {
                    directOpenModal('newNoteModal');
                });
            }
            
            const newFolderBtn = document.querySelector('.file-tree-actions .action-btn:nth-child(2)');
            if (newFolderBtn) {
                newFolderBtn.addEventListener('click', function() {
                    directOpenModal('newFolderModal');
                });
            }
            
            const sortBtn = document.querySelector('.file-tree-actions .action-btn:nth-child(3)');
            if (sortBtn) {
                sortBtn.addEventListener('click', function() {
                    const sortMenu = document.getElementById('sortMenu');
                    if (sortMenu) {
                        sortMenu.classList.toggle('active');
                    }
                });
            }
            
            // Add click handler to sort menu items
            document.querySelectorAll('.sort-menu-item').forEach(item => {
                item.addEventListener('click', function() {
                    const sortType = this.getAttribute('onclick').match(/'([^']+)'/)[1];
                    sortFileSystem(sortType);
                    document.getElementById('sortMenu').classList.remove('active');
                });
            });
        });
    </script>
    <script>
        // Function to render the file tree
        function renderFileTree() {
            const fileTreeElement = document.getElementById('fileTree');
            if (!fileTreeElement) {
                console.error('File tree element not found');
                return;
            }
            
            try {
            // Clear existing content
            fileTreeElement.innerHTML = '';
                
                // Make sure fileSystem and expandedFolders are defined
                if (typeof fileSystem === 'undefined') {
                    window.fileSystem = {
                        id: 'root',
                        type: 'folder',
                        children: []
                    };
                }
                
                if (typeof expandedFolders === 'undefined') {
                    window.expandedFolders = new Set(['root']);
                }
            
            // Render the root folder's children
            renderFolder(fileTreeElement, fileSystem);
            
                console.log('File tree rendered successfully');
            } catch (error) {
                console.error('Error rendering file tree:', error);
                // Show simple UI with error
                fileTreeElement.innerHTML = `
                    <div class="tree-error">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Error loading files</p>
                        <button onclick="location.reload()" class="tree-retry-btn">Retry</button>
                    </div>
                `;
            }
        }
        
        // Function to render a folder and its children
        function renderFolder(parentElement, folder) {
            try {
            const isExpanded = expandedFolders.has(folder.id);
            
            if (folder.id !== 'root') {
                // Create folder item
                const folderElement = document.createElement('div');
                folderElement.className = 'tree-item' + (isExpanded ? ' expanded' : '');
                folderElement.dataset.id = folder.id;
                
                // Create folder content
                const folderContent = document.createElement('div');
                folderContent.className = 'tree-item-content' + (selectedItemId === folder.id ? ' selected' : '');
                folderContent.innerHTML = `
                    <span class="tree-item-toggle"><i class="fas fa-chevron-right"></i></span>
                    <span class="tree-item-icon"><i class="fas fa-folder${isExpanded ? '-open' : ''}"></i></span>
                    <span class="tree-item-text">${folder.name}</span>
                `;
                
                // Add click event to toggle folder
                folderContent.addEventListener('click', function(e) {
                    // If clicking on the toggle icon or anywhere on the folder content
                    toggleFolder(folder.id);
                    e.stopPropagation();
                    // No longer selecting the folder when clicked
                });
                
                folderElement.appendChild(folderContent);
                
                // Create container for children
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'tree-item-children';
                folderElement.appendChild(childrenContainer);
                
                parentElement.appendChild(folderElement);
                
                // If expanded, render children
                if (isExpanded && folder.children && folder.children.length > 0) {
                    folder.children.forEach(child => {
                        if (child.type === 'folder') {
                            renderFolder(childrenContainer, child);
                        } else {
                            renderFile(childrenContainer, child);
                        }
                    });
                }
            } else {
                // For root folder, just render its children directly
                if (folder.children && folder.children.length > 0) {
                    folder.children.forEach(child => {
                        if (child.type === 'folder') {
                            renderFolder(parentElement, child);
                        } else {
                            renderFile(parentElement, child);
                        }
                    });
                }
                }
            } catch (error) {
                console.error('Error rendering folder:', error);
            }
        }
        
        // Function to render a file
        function renderFile(parentElement, file) {
            try {
            const fileElement = document.createElement('div');
            fileElement.className = 'tree-item';
            fileElement.dataset.id = file.id;
            
            // Create file content
            const fileContent = document.createElement('div');
            fileContent.className = 'tree-item-content' + (selectedItemId === file.id ? ' selected' : '');
            
            // Choose icon based on file type
            let fileIcon = 'fa-file';
            if (file.fileType === 'pdf') {
                fileIcon = 'fa-file-pdf';
            } else if (file.fileType === 'image') {
                fileIcon = 'fa-file-image';
            } else if (file.fileType === 'doc' || file.fileType === 'docx') {
                fileIcon = 'fa-file-word';
                } else if (file.fileType === 'md' || file.fileType === 'markdown') {
                    fileIcon = 'fa-file-markdown';
            }
            
            fileContent.innerHTML = `
                    <span class="tree-item-toggle" style="visibility: hidden;"><i class="fas ${fileIcon}"></i></span>
                <span class="tree-item-text">${file.name}</span>
            `;
            
            // Add click event to select file
            fileContent.addEventListener('click', function() {
                selectItem(file.id);
                // Simulate opening the file
                console.log(`Opening file: ${file.name}`);
            });
            
            fileElement.appendChild(fileContent);
            parentElement.appendChild(fileElement);
            } catch (error) {
                console.error('Error rendering file:', error);
            }
        }
        
        // Function to toggle folder expansion
        function toggleFolder(folderId) {
            try {
            if (expandedFolders.has(folderId)) {
                expandedFolders.delete(folderId);
            } else {
                expandedFolders.add(folderId);
            }
            
            renderFileTree();
            } catch (error) {
                console.error('Error toggling folder:', error);
            }
        }
        
        // Make the functions globally accessible
        window.renderFileTree = renderFileTree;
        window.renderFolder = renderFolder;
        window.renderFile = renderFile;
        window.toggleFolder = toggleFolder;
        window.showEmptyWorkspaceMessage = showEmptyWorkspaceMessage;
        window.hideEmptyWorkspaceMessage = hideEmptyWorkspaceMessage;
        window.directOpenModal = directOpenModal;
        window.directCloseModal = directCloseModal;
        window.initializeFileSystem = initializeFileSystem;
        window.ensureEmptyFileTree = ensureEmptyFileTree;
        
        // Initialize file system
        function initializeFileSystem() {
            console.log('Initializing file system');
            
            // Always start with empty file system
            window.fileSystem = {
                id: 'root',
                type: 'folder',
                children: []
            };
            
            // Reset expandedFolders
            if (window.expandedFolders) {
                window.expandedFolders.clear();
                window.expandedFolders.add('root');
            }
            
            // Reset selected item
            window.selectedItemId = null;
            
            // Render empty file tree
            if (typeof window.renderFileTree === 'function') {
                window.renderFileTree();
            } else {
                const fileTreeElement = document.getElementById('fileTree');
                if (fileTreeElement) {
                    fileTreeElement.innerHTML = '';
                }
            }
            
            // Check if we have a workspace folder set in localStorage
            const savedPath = localStorage.getItem('workspaceFolderPath');
            
            if (!savedPath) {
                console.log('No workspace folder set, showing empty state');
                showEmptyWorkspaceMessage();
            } else {
                console.log('Workspace folder found in localStorage:', savedPath);
                // Update the input field
                const workspacePath = document.getElementById('workspacePath');
                if (workspacePath) {
                    workspacePath.value = savedPath;
                }
                
                // If we have a workspace folder handle, use it
                if (window.workspaceFolderHandle) {
                    updateFileSystemFromLocalFolder(window.workspaceFolderHandle).catch(error => {
                        console.error('Failed to update from folder handle:', error);
                        showEmptyWorkspaceMessage();
                    });
                } else {
                    showEmptyWorkspaceMessage();
                }
            }
        }
        
        // Function to show empty workspace message
        function showEmptyWorkspaceMessage() {
            console.log('Showing empty workspace message');
            
            // Find or create PDF viewer
            const pdfViewer = document.getElementById('pdfViewer');
            if (!pdfViewer) {
                console.error('PDF viewer element not found');
                        return;
                    }
                    
            // Find or create PDF container
            let pdfContainer = document.getElementById('pdfContainer');
            if (!pdfContainer) {
                console.log('Creating new PDF container');
                pdfContainer = document.createElement('div');
                pdfContainer.id = 'pdfContainer';
                pdfContainer.className = 'pdf-container';
                pdfViewer.appendChild(pdfContainer);
            } else {
                // Clear existing content
                pdfContainer.innerHTML = '';
            }
            
            // Create and add empty workspace message
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-workspace-message';
            emptyMessage.innerHTML = `
                <i class="fas fa-folder-open"></i>
                <h3>No Workspace Folder Selected</h3>
                <p>Select a local folder to use as your workspace in Settings > PDF Viewer.</p>
                <button id="selectWorkspaceFolderBtn" class="modal-btn modal-btn-primary">
                    <i class="fas fa-folder"></i> Select Folder
                </button>
            `;
            pdfContainer.appendChild(emptyMessage);
            
            // Add click handler to the button
            const selectBtn = document.getElementById('selectWorkspaceFolderBtn');
            if (selectBtn) {
                selectBtn.addEventListener('click', function() {
                    // Open settings modal
                    directOpenModal('settingsModal');
                    
                    // Switch to PDF viewer tab
                    const pdfViewerTab = document.querySelector('.settings-sidebar li[data-setting="pdf-viewer"]');
                    if (pdfViewerTab) {
                        pdfViewerTab.click();
                    }
                });
            }
        }
        
        // Function to hide empty workspace message
        function hideEmptyWorkspaceMessage() {
            const emptyMessage = document.querySelector('.empty-workspace-message');
            if (emptyMessage) {
                emptyMessage.remove();
            }
        }
        
        // DOM loaded event handler
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM content loaded');
            
            // Initialize with empty file system
            window.fileSystem = {
                id: 'root',
                type: 'folder',
                children: []
            };
            
            // Initialize empty file tree
            const fileTreeElement = document.getElementById('fileTree');
            if (fileTreeElement) {
                fileTreeElement.innerHTML = '';
            }
            
            // Remove any existing event listeners
            removeExistingEventListeners();
            
            // Initialize file system and check for workspace folder
            initializeFileSystem();
            
            // Add UI event listeners
            addUIEventListeners();
            
            // Show empty workspace message immediately if no folder is selected
            if (!savedPath) {
                showEmptyWorkspaceMessage();
            }
        });
        
        // Remove any existing event listeners
        function removeExistingEventListeners() {
            // For settings button
            const settingsBtn = document.getElementById('sidebarSettingsBtn');
            if (settingsBtn) {
                const newSettingsBtn = settingsBtn.cloneNode(true);
                settingsBtn.parentNode.replaceChild(newSettingsBtn, settingsBtn);
            }
            
            // For workspace folder selection button
            const selectWorkspaceFolderBtn = document.getElementById('selectWorkspaceFolder');
            if (selectWorkspaceFolderBtn) {
                const newSelectBtn = selectWorkspaceFolderBtn.cloneNode(true);
                selectWorkspaceFolderBtn.parentNode.replaceChild(newSelectBtn, selectWorkspaceFolderBtn);
            }
            
            // For save settings button
            const saveSettingsBtn = document.getElementById('saveSettingsBtn');
            if (saveSettingsBtn) {
                const newSaveBtn = saveSettingsBtn.cloneNode(true);
                saveSettingsBtn.parentNode.replaceChild(newSaveBtn, saveSettingsBtn);
            }
            
            // For close buttons
            document.querySelectorAll('.modal-close').forEach(function(btn) {
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
            });
            
            // For modal overlays
            document.querySelectorAll('.modal-overlay').forEach(function(overlay) {
                const newOverlay = overlay.cloneNode(false);
                while (overlay.firstChild) {
                    newOverlay.appendChild(overlay.firstChild);
                }
                overlay.parentNode.replaceChild(newOverlay, overlay);
            });
        }
        
        // Add UI event listeners
        function addUIEventListeners() {
            // Add click handler to settings button
            const settingsBtn = document.getElementById('sidebarSettingsBtn');
            if (settingsBtn) {
                settingsBtn.addEventListener('click', function() {
                    console.log('Settings button clicked');
                    directOpenModal('settingsModal');
                });
            }
            
            // Add click handlers to close buttons
            const closeButtons = document.querySelectorAll('.modal-close');
            closeButtons.forEach(function(btn) {
                btn.addEventListener('click', function() {
                    const modalId = this.closest('.modal-overlay').id;
                    directCloseModal(modalId);
                });
            });
            
            // Add workspace folder selection event listener
            const selectWorkspaceFolderBtn = document.getElementById('selectWorkspaceFolder');
            if (selectWorkspaceFolderBtn) {
                selectWorkspaceFolderBtn.addEventListener('click', function() {
                    selectWorkspaceFolder();
                });
            }
            
            // Add save settings button event listener
            const saveSettingsBtn = document.getElementById('saveSettingsBtn');
            if (saveSettingsBtn) {
                saveSettingsBtn.addEventListener('click', function() {
                    saveSettings();
                });
            }
            
            // Add click handler to modal overlay for closing when clicking outside
            const modalOverlays = document.querySelectorAll('.modal-overlay');
            modalOverlays.forEach(function(overlay) {
                overlay.addEventListener('click', function(e) {
                    if (e.target === this) {
                        directCloseModal(this.id);
                    }
                });
            });
        }
        
        window.removeExistingEventListeners = removeExistingEventListeners;
        window.addUIEventListeners = addUIEventListeners;
    </script>
    <!-- Helper function to fine-tune text layer alignment after rendering -->
    <script>
        function finetuneTextLayerAlignment(textLayer, viewport) {
            // We're using a different approach now, focusing on individual text spans
            // The previous implementation is no longer needed
            return;
        }
        
        // Helper function to adjust text span styles for proper alignment
        function adjustTextSpanStyles(textLayer) {
            const textSpans = textLayer.querySelectorAll('span');
            
            if (textSpans.length === 0) {
                const divElements = textLayer.querySelectorAll('div');
                if (divElements.length > 0) {
                    console.log('[Adjust] Found div elements instead of spans, adjusting those');
                    applyStyleAdjustments(divElements);
                } else {
                    console.log('[Adjust] No text elements found to adjust');
                }
            } else {
                console.log(`[Adjust] Adjusting ${textSpans.length} text spans`);
                applyStyleAdjustments(textSpans);
            }
            
            function applyStyleAdjustments(elements) {
                // First, identify lines by grouping elements with similar y-positions
                const lineGroups = {};
                const tolerance = 2; // Pixels of tolerance for considering elements on the same line
                
                elements.forEach(element => {
                    const rect = element.getBoundingClientRect();
                    const top = Math.round(rect.top);
                    
                    // Find the closest line group
                    let foundGroup = false;
                    for (const lineY in lineGroups) {
                        if (Math.abs(top - parseInt(lineY)) <= tolerance) {
                            lineGroups[lineY].push(element);
                            foundGroup = true;
                            break;
                        }
                    }
                    
                    // Create a new line group if not found
                    if (!foundGroup) {
                        lineGroups[top] = [element];
                    }
                });
                
                // Process each line group
                Object.values(lineGroups).forEach(lineElements => {
                    // Sort elements by their left position
                    lineElements.sort((a, b) => {
                        return a.getBoundingClientRect().left - b.getBoundingClientRect().left;
                    });
                    
                    // For adjacent spans, ensure spacing is precise
                    for (let i = 0; i < lineElements.length - 1; i++) {
                        const currentElement = lineElements[i];
                        const nextElement = lineElements[i + 1];
                        
                        // Set explicit data attributes to help with selection
                        currentElement.dataset.lineIndex = i;
                        currentElement.dataset.lineTotal = lineElements.length;
                        
                        // Mark adjacent spans
                        if (i < lineElements.length - 1) {
                            currentElement.dataset.hasNextSpan = 'true';
                            nextElement.dataset.hasPrevSpan = 'true';
                        }
                    }
                    
                    // Apply styling to each element in the line
                    lineElements.forEach((element, index) => {
                        // Preserve original positioning
                        const originalStyle = element.getAttribute('style') || '';
                        
                        // Extract positioning styles
                        const leftMatch = originalStyle.match(/left:\s*([^;]+)/);
                        const topMatch = originalStyle.match(/top:\s*([^;]+)/);
                        const fontSizeMatch = originalStyle.match(/font-size:\s*([^;]+)/);
                        const fontFamilyMatch = originalStyle.match(/font-family:\s*([^;]+)/);
                        
                        // Create a new style string preserving original positioning
                        let newStyle = '';
                        
                        if (leftMatch) newStyle += `left: ${leftMatch[1]}; `;
                        if (topMatch) newStyle += `top: ${topMatch[1]}; `;
                        if (fontSizeMatch) newStyle += `font-size: ${fontSizeMatch[1]}; `;
                        if (fontFamilyMatch) newStyle += `font-family: ${fontFamilyMatch[1]}; `;
                        
                        // Add the exact scale transform from the image
                        newStyle += 'transform: scaleX(1.0); transform-origin: 0% 0%;';
                        
                        // Make selection more precise with slight padding adjustments
                        newStyle += 'padding: 0px; margin: 0px; ';
                        
                        // Apply the new style
                        element.setAttribute('style', newStyle);
                        
                        // Make sure the element has correct role and properties
                        element.setAttribute('role', 'presentation');
                        
                        // Add data attributes to help with selection
                        element.dataset.index = index;
                    });
                });
                
                // Add selection improvement listener
                addSelectionImprovementListener(textLayer);
                
                console.log(`[Adjust] Adjusted ${elements.length} elements across ${Object.keys(lineGroups).length} lines`);
            }
            
            // Function to improve selection across spans
            function addSelectionImprovementListener(textLayer) {
                // We only need to add this listener once per text layer
                if (textLayer.dataset.selectionListenerAdded) return;
                
                textLayer.addEventListener('mouseup', function(e) {
                    // Get the current selection
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;
                    
                    // Check if we have a selection that spans multiple elements
                    if (selection.anchorNode !== selection.focusNode) {
                        // Get all text spans between the anchor and focus nodes
                        const allSpans = Array.from(textLayer.querySelectorAll('span'));
                        
                        // Find the spans containing the anchor and focus nodes
                        let anchorSpan = null;
                        let focusSpan = null;
                        
                        for (const span of allSpans) {
                            if (span.contains(selection.anchorNode)) {
                                anchorSpan = span;
                            }
                            if (span.contains(selection.focusNode)) {
                                focusSpan = span;
                            }
                        }
                        
                        // No need to continue if we couldn't find both spans
                        if (!anchorSpan || !focusSpan) return;
                        
                        // Get indices of spans in the array
                        const anchorIndex = allSpans.indexOf(anchorSpan);
                        const focusIndex = allSpans.indexOf(focusSpan);
                        
                        // No need to continue if both spans are the same
                        if (anchorIndex === focusIndex) return;
                        
                        // Make sure anchorIndex is the smaller one
                        const startIndex = Math.min(anchorIndex, focusIndex);
                        const endIndex = Math.max(anchorIndex, focusIndex);
                        
                        // Ensure we're selecting full spans for any spans between start and end
                        for (let i = startIndex + 1; i < endIndex; i++) {
                            const intermediateSpan = allSpans[i];
                            if (intermediateSpan) {
                                // Check if this span is already fully selected
                                if (!isSpanFullySelected(intermediateSpan, selection)) {
                                    // If not fully selected, we need to ensure it's added to the selection
                                    extendSelectionToIncludeSpan(selection, intermediateSpan);
                                }
                            }
                        }
                    }
                });
                
                // Mark that we've added the listener
                textLayer.dataset.selectionListenerAdded = 'true';
            }
            
            // Helper function to check if a span is fully selected
            function isSpanFullySelected(span, selection) {
                if (!selection.rangeCount) return false;
                
                const range = selection.getRangeAt(0);
                
                // If the range contains the span's start and end, it's fully selected
                return range.intersectsNode(span) && 
                       range.comparePoint(span, 0) <= 0 && 
                       range.comparePoint(span, span.childNodes.length) >= 0;
            }
            
            // Helper function to extend selection to include a span
            function extendSelectionToIncludeSpan(selection, span) {
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                
                // Create a new range that includes the current range plus the span
                const newRange = range.cloneRange();
                
                // Extend the range to include the span if needed
                if (range.comparePoint(span, 0) > 0) {
                    newRange.setStartBefore(span);
                }
                
                if (range.comparePoint(span, span.childNodes.length) < 0) {
                    newRange.setEndAfter(span);
                }
                
                // Replace the selection with our extended range
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
        }
        
        // Export the function to window so it can be called from pdf.js
        window.adjustTextSpanStyles = adjustTextSpanStyles;
    </script>
    <script>
        // Function to clear search results - alias for clarity
        window.clearSearchResults = function() {
            // Make sure we're using the function in the correct scope
            if (typeof clearSearchHighlights === 'function') {
                clearSearchHighlights();
            } else {
                // Manually clear highlights if function isn't available
                const searchOverlays = document.querySelectorAll('.search-overlay');
                searchOverlays.forEach(overlay => {
                    if (overlay && overlay.parentNode) {
                        console.log('[clearSearchResults] Removing overlay:', overlay);
                        overlay.parentNode.removeChild(overlay);
                    }
                });
                
                // Reset search state manually
                if (typeof searchState !== 'undefined') {
                    searchState.matches = [];
                    searchState.currentMatchIndex = -1;
                    searchState.overlays = [];
                }
            }
            
            // Reset UI elements
            const searchCount = document.getElementById('searchCount');
            if (searchCount) {
                searchCount.textContent = '';
            }
            
            // Disable navigation buttons
            const prevResultBtn = document.getElementById('prevResult');
            const nextResultBtn = document.getElementById('nextResult');
            if (prevResultBtn) prevResultBtn.disabled = true;
            if (nextResultBtn) nextResultBtn.disabled = true;
        };
    </script>
    <!-- Search Utility Functions -->
    <script>
        window.adjustTextSpanStyles = adjustTextSpanStyles;
    </script>
    <!-- Markdown Functions -->
    <script>
        // Global variables for markdown handling
        let markdownEditor = null;
        let currentMarkdownFile = null;
        let markdownViewMode = 'edit'; // Default view mode: edit, split, or preview
        
        // Function to load markdown file
        window.loadMarkdown = function(fileUrl, fileName = 'Untitled') {
            console.log(`[Markdown] Loading markdown: ${fileName} from ${fileUrl}`);
            
            // First ensure the markdown section is visible and containers exist
            if (typeof window.ensureMarkdownSectionVisible === 'function') {
                const containers = window.ensureMarkdownSectionVisible();
                if (!containers.markdownContainer || !containers.markdownEditor || !containers.markdownPreview) {
                    console.error('[Markdown] Failed to ensure markdown containers exist');
                    return false;
                }
            }
            
            // Update title if element exists
            const markdownTitle = document.getElementById('markdownTitle');
            if (markdownTitle) {
                markdownTitle.textContent = fileName;
            }
            
            // Get or create markdown containers
            const markdownContainer = document.getElementById('markdownContainer');
            const editorElement = document.getElementById('markdownEditor');
            const previewElement = document.getElementById('markdownPreview');
            
            if (!markdownContainer || !editorElement || !previewElement) {
                console.error('[Markdown] Markdown containers not found');
                return false;
            }
            
            // Clear previous content if editor isn't initialized yet
            if (!window.markdownEditor) {
                editorElement.innerHTML = '';
            }
            previewElement.innerHTML = '<div class="markdown-loading"><i class="fas fa-spinner fa-spin"></i> Loading...</div>';
            
            try {
                // Ensure required libraries are loaded
                if (typeof marked === 'undefined' || typeof CodeMirror === 'undefined') {
                    console.error('[Markdown] Required libraries not loaded');
                    if (typeof ensureMarkdownFunctionsAvailable === 'function') {
                        ensureMarkdownFunctionsAvailable();
                        
                        // If libraries aren't loaded, retry in a moment
                        setTimeout(() => {
                            if (typeof marked !== 'undefined' && typeof CodeMirror !== 'undefined') {
                                console.log('[Markdown] Libraries now loaded, retrying load');
                                window.loadMarkdown(fileUrl, fileName);
                            }
                        }, 1000);
                        return false;
                    }
                }
                
                // Fetch the markdown content
                fetch(fileUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(markdownContent => {
                        // Save current file reference
                        currentMarkdownFile = {
                            url: fileUrl,
                            name: fileName,
                            content: markdownContent
                        };
                        
                        // Initialize CodeMirror editor if not already initialized
                        if (!window.markdownEditor) {
                            window.markdownEditor = CodeMirror(editorElement, {
                                value: markdownContent,
                                mode: 'markdown',
                                lineNumbers: true,
                                lineWrapping: true,
                                theme: 'default',
                                extraKeys: {
                                    'Ctrl-S': function() {
                                        saveMarkdownFile();
                                    }
                                }
                            });
                            
                            // Add event listener for content changes
                            window.markdownEditor.on('change', function() {
                                updateMarkdownPreview();
                            });
                        } else {
                            // Just update content if editor already exists
                            window.markdownEditor.setValue(markdownContent);
                        }
                        
                        // Initial preview render
                        if (typeof updateMarkdownPreview === 'function') {
                            updateMarkdownPreview();
                        } else {
                            console.error('[Markdown] updateMarkdownPreview function not available');
                            // Basic fallback
                            if (typeof marked !== 'undefined') {
                                previewElement.innerHTML = marked.parse(markdownContent);
                            } else {
                                previewElement.innerHTML = `<pre>${markdownContent}</pre>`;
                            }
                        }
                        
                        // Set the view mode
                        if (typeof setMarkdownViewMode === 'function') {
                            setMarkdownViewMode(markdownViewMode);
                        }
                        
                        console.log(`[Markdown] Successfully loaded markdown: ${fileName}`);
                        return true;
                    })
                    .catch(error => {
                        console.error('[Markdown] Error loading markdown file:', error);
                        previewElement.innerHTML = `<div class="markdown-error">Error loading markdown: ${error.message}</div>`;
                        return false;
                    });
            } catch (error) {
                console.error('[Markdown] Error in loadMarkdown:', error);
                return false;
            }
            
            return true;
        };
        
        // Function to load markdown from a File object (for local files)
        window.loadMarkdownFromFile = function(file) {
            console.log(`[Markdown] Loading markdown from file object: ${file.name}`);
            
            if (!file) {
                console.error('[Markdown] Invalid file object');
                return false;
            }
            
            // First ensure the markdown section is visible and containers exist
            if (typeof window.ensureMarkdownSectionVisible === 'function') {
                const containers = window.ensureMarkdownSectionVisible();
                if (!containers.markdownContainer) {
                    console.error('[Markdown] Failed to ensure markdown container exists');
                    return false;
                }
            }
            
            // First make sure the required libraries are loaded
            let librariesAvailable = true;
            
            // Check for marked
            if (typeof marked === 'undefined') {
                console.error('[Markdown] Marked library not loaded');
                librariesAvailable = false;
                
                // Try to inject the Marked library
                if (!document.querySelector('script[src*="marked"]')) {
                    const markedScript = document.createElement('script');
                    markedScript.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
                    document.head.appendChild(markedScript);
                    console.log('[Markdown] Injected Marked library script');
                }
            }
            
            // Check for CodeMirror
            if (typeof CodeMirror === 'undefined') {
                console.error('[Markdown] CodeMirror not loaded');
                librariesAvailable = false;
                
                // Try to inject CodeMirror
                if (!document.querySelector('script[src*="codemirror"]')) {
                    // Add the CSS
                    const cmCSS = document.createElement('link');
                    cmCSS.rel = 'stylesheet';
                    cmCSS.href = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css';
                    document.head.appendChild(cmCSS);
                    
                    // Add the JS
                    const cmScript = document.createElement('script');
                    cmScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js';
                    document.head.appendChild(cmScript);
                    
                    // Add the markdown mode
                    const modeScript = document.createElement('script');
                    modeScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js';
                    document.head.appendChild(modeScript);
                    
                    console.log('[Markdown] Injected CodeMirror scripts and styles');
                }
            }
            
            // Try to load libraries if needed
            if (!librariesAvailable) {
                if (typeof ensureMarkdownFunctionsAvailable === 'function') {
                    ensureMarkdownFunctionsAvailable();
                }
                
                // Show fallback while waiting for libraries
                const markdownPreview = document.getElementById('markdownPreview');
                if (markdownPreview) {
                    markdownPreview.innerHTML = '<div style="text-align:center;padding:20px;"><i class="fas fa-spinner fa-spin"></i> Loading required libraries...</div>';
                }
            }
            
            // Show loading indicator
            const markdownContainer = document.getElementById('markdownContainer');
            if (markdownContainer) {
                const loadingHtml = '<div class="markdown-loading" style="text-align:center;padding:20px;"><i class="fas fa-spinner fa-spin"></i> Loading markdown...</div>';
                markdownContainer.innerHTML = loadingHtml;
            }
            
            try {
                // Read the file content
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    console.log('[Markdown] File read successfully, content length:', content.length);
                    
                    // Store the content in a global variable for potential reuse
                    window.currentMarkdownFile = {
                        name: file.name,
                        content: content,
                        file: file
                    };
                    
                    // Use the direct content creation function
                    if (typeof window.createMarkdownContent === 'function') {
                        window.createMarkdownContent(content, file.name);
                    } else {
                        console.error('[Markdown] Content creation function not available');
                        
                        // Fallback
                        const editorElement = document.getElementById('markdownEditor');
                        const previewElement = document.getElementById('markdownPreview');
                        
                        if (editorElement) {
                            editorElement.innerHTML = `<pre style="white-space:pre-wrap;word-break:break-all;">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                        }
                        
                        if (previewElement && typeof marked !== 'undefined') {
                            previewElement.innerHTML = marked.parse(content);
                        } else if (previewElement) {
                            previewElement.innerHTML = `<pre style="white-space:pre-wrap;word-break:break-all;">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                        }
                    }
                };
                reader.onerror = function(e) {
                    console.error('[Markdown] Error reading file:', e);
                    
                    // Show error message
                    if (markdownContainer) {
                        markdownContainer.innerHTML = `<div class="markdown-error">Error reading file: ${e.message || 'Unknown error'}</div>`;
                    }
                    return false;
                };
                reader.readAsText(file);
                return true;
            } catch (error) {
                console.error('[Markdown] Error in loadMarkdownFromFile:', error);
                
                // Show error message
                if (markdownContainer) {
                    markdownContainer.innerHTML = `<div class="markdown-error">Error: ${error.message || 'Unknown error'}</div>`;
                }
                return false;
            }
        };
        
        // Make the function available globally
        window.ensureMarkdownFunctionsAvailable = ensureMarkdownFunctionsAvailable;
    </script>
    <!-- Function to ensure markdown functions are available -->
    <script>
        // Function to ensure markdown functions are available
        function ensureMarkdownFunctionsAvailable() {
            console.log('[Markdown] Ensuring markdown functions are available');
            
            let allLibrariesLoaded = true;
            
            // Check if the Marked library is loaded
            if (typeof marked === 'undefined') {
                console.error('[Markdown] Marked library is not loaded');
                allLibrariesLoaded = false;
                
                // Check if the script is already in the document but not loaded yet
                const existingScript = document.querySelector('script[src*="marked"]');
                if (!existingScript) {
                    // Add the script dynamically
                    const markedScript = document.createElement('script');
                    markedScript.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
                    document.head.appendChild(markedScript);
                }
            }
            
            // Check if CodeMirror is loaded
            if (typeof CodeMirror === 'undefined') {
                console.error('[Markdown] CodeMirror is not loaded');
                allLibrariesLoaded = false;
                
                // Check if the script is already in the document but not loaded yet
                const existingScript = document.querySelector('script[src*="codemirror"]');
                if (!existingScript) {
                    // Add the styles if not already present
                    if (!document.querySelector('link[href*="codemirror"]')) {
                        const codeMirrorCSS = document.createElement('link');
                        codeMirrorCSS.rel = 'stylesheet';
                        codeMirrorCSS.href = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css';
                        document.head.appendChild(codeMirrorCSS);
                    }
                    
                    // Add the scripts
                    const codeMirrorScript = document.createElement('script');
                    codeMirrorScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js';
                    document.head.appendChild(codeMirrorScript);
                    
                    // Add mode script
                    const modeScript = document.createElement('script');
                    modeScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js';
                    document.head.appendChild(modeScript);
                }
            }
            
            // Check if Prism is loaded (for syntax highlighting)
            if (typeof Prism === 'undefined') {
                console.error('[Markdown] Prism is not loaded');
                allLibrariesLoaded = false;
                
                // Check if the script is already in the document but not loaded yet
                const existingScript = document.querySelector('script[src*="prism"]');
                if (!existingScript) {
                    // Add the styles if not already present
                    if (!document.querySelector('link[href*="prism"]')) {
                        const prismCSS = document.createElement('link');
                        prismCSS.rel = 'stylesheet';
                        prismCSS.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css';
                        document.head.appendChild(prismCSS);
                    }
                    
                    // Add the scripts
                    const prismScript = document.createElement('script');
                    prismScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js';
                    document.head.appendChild(prismScript);
                    
                    // Add language scripts
                    const languages = ['markdown', 'javascript', 'python', 'css', 'html'];
                    languages.forEach(lang => {
                        const langScript = document.createElement('script');
                        langScript.src = `https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-${lang}.min.js`;
                        document.head.appendChild(langScript);
                    });
                }
            }
            
            // If libraries were missing, display a message
            if (!allLibrariesLoaded) {
                // Display a helpful message in the markdown container
                const markdownPreview = document.getElementById('markdownPreview');
                if (markdownPreview) {
                    markdownPreview.innerHTML = `
                        <div class="markdown-loading">
                            <i class="fas fa-spinner fa-spin"></i>
                            <p>Loading required libraries...</p>
                            <p>Please try selecting the file again in a moment.</p>
                        </div>
                    `;
                }
                
                return false;
            }
            
            return true;
        }
        
        // Make function available globally
        window.ensureMarkdownFunctionsAvailable = ensureMarkdownFunctionsAvailable;
    </script>
    <!-- Function to update the markdown preview -->
    <script>
        function updateMarkdownPreview() {
            const markdownPreview = document.getElementById('markdownPreview');
            if (!markdownPreview) {
                console.error('[Markdown] Preview element not found');
                return;
            }
            
            let content = '';
            
            try {
                // Try to get content from our wrapper object
                if (window.markdownEditor && typeof window.markdownEditor.getValue === 'function') {
                    content = window.markdownEditor.getValue();
                }
                // Fallback to textarea if CodeMirror isn't available
                else {
                    const textarea = document.getElementById('markdownTextarea');
                    if (textarea) {
                        content = textarea.value;
                    } else {
                        console.error('[Markdown] No editor content found');
                        return;
                    }
                }
                
                // Check if marked library is available
                if (typeof marked === 'undefined') {
                    console.error('[Markdown] Marked library not available for rendering');
                    markdownPreview.innerHTML = `
                        <div class="markdown-error">
                            <p>Error: Marked library not available for rendering.</p>
                            <pre>${content ? content.replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'No content'}</pre>
                        </div>
                    `;
                    return;
                }
                
                // Use Marked.js to convert markdown to HTML
                const parsedContent = marked.parse(content, {
                    gfm: true, // GitHub Flavored Markdown
                    breaks: true, // Convert line breaks to <br>
                    sanitize: false, // Allow HTML
                    smartLists: true,
                    smartypants: true,
                    highlight: function(code, lang) {
                        // Use Prism for syntax highlighting if available
                        if (Prism && Prism.highlight && Prism.languages[lang]) {
                            return Prism.highlight(code, Prism.languages[lang], lang);
                        }
                        return code;
                    }
                });
                
                // Wrap with styled container to ensure proper display
                markdownPreview.innerHTML = `
                    <div class="marked-content" style="padding:20px;height:100%;overflow:auto;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;">
                        ${parsedContent}
                    </div>
                `;
                
                // Apply styles to specific elements
                const styledElements = markdownPreview.querySelectorAll('h1, h2, h3, h4, h5, h6, p, ul, ol, pre, blockquote, table');
                styledElements.forEach(el => {
                    if (el.tagName === 'H1') {
                        el.style.borderBottom = '1px solid #eaecef';
                        el.style.paddingBottom = '0.3em';
                    }
                    if (el.tagName === 'H2') {
                        el.style.borderBottom = '1px solid #eaecef';
                        el.style.paddingBottom = '0.3em';
                    }
                    if (el.tagName === 'BLOCKQUOTE') {
                        el.style.borderLeft = '0.25em solid #dfe2e5';
                        el.style.color = '#6a737d';
                        el.style.padding = '0 1em';
                    }
                    if (el.tagName === 'PRE') {
                        el.style.padding = '16px';
                        el.style.overflow = 'auto';
                        el.style.fontSize = '85%';
                        el.style.lineHeight = '1.45';
                        el.style.backgroundColor = '#f6f8fa';
                        el.style.borderRadius = '3px';
                    }
                    if (el.tagName === 'TABLE') {
                        el.style.borderCollapse = 'collapse';
                        el.style.width = '100%';
                        el.style.overflow = 'auto';
                        el.style.display = 'block';
                        el.style.marginBottom = '16px';
                    }
                });
                
                // Apply styles to table elements
                const tableElements = markdownPreview.querySelectorAll('table th, table td');
                tableElements.forEach(el => {
                    el.style.padding = '6px 13px';
                    el.style.border = '1px solid #dfe2e5';
                });
                
                // Apply syntax highlighting to code blocks
                if (typeof Prism !== 'undefined') {
                    Prism.highlightAllUnder(markdownPreview);
                }
            } catch (error) {
                console.error('[Markdown] Error updating preview:', error);
                markdownPreview.innerHTML = `<div class="markdown-error">Error rendering preview: ${error.message}</div>`;
                
                // Try to at least show raw content
                if (content) {
                    markdownPreview.innerHTML += `<pre>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                }
            }
        }
        
        // Function to set the markdown view mode
        function setMarkdownViewMode(mode) {
            console.log('[Markdown] Setting view mode to:', mode);
            
            const editor = document.getElementById('markdownEditor');
            const preview = document.getElementById('markdownPreview');
            const container = document.getElementById('markdownContainer');
            const splitView = document.querySelector('.markdown-split-view');
            
            if (!editor || !preview || !container || !splitView) {
                console.error('[Markdown] Required elements not found for setting view mode');
                return;
            }
            
            // Store the current mode
            window.markdownViewMode = mode;
            
            // Update button active states
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.classList.remove('active');
                // Also remove styles that might have been added directly
                btn.style.backgroundColor = '';
                btn.style.color = 'var(--text-secondary, #666)';
            });
            
            const activeBtn = document.querySelector(`.view-mode-btn[data-mode="${mode}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                // Add styles directly
                activeBtn.style.backgroundColor = 'var(--accent-primary, #007bff)';
                activeBtn.style.color = 'white';
            }
            
            // Apply the appropriate layout
            splitView.style.display = 'flex'; // Reset display
            
            try {
                switch (mode) {
                    case 'edit':
                        editor.style.display = 'block';
                        preview.style.display = 'none';
                        splitView.style.flexDirection = 'column';
                        break;
                    case 'preview':
                        editor.style.display = 'none';
                        preview.style.display = 'block';
                        splitView.style.flexDirection = 'column';
                        break;
                    case 'split':
                        editor.style.display = 'block';
                        preview.style.display = 'block';
                        splitView.style.flexDirection = 'row';
                        break;
                }
                
                // Resize editor if we have a valid CodeMirror instance
                if (window.markdownEditor) {
                    // Use our wrapper object if it has a refresh method
                    if (typeof window.markdownEditor.refresh === 'function') {
                        window.markdownEditor.refresh();
                    }
                    // Try the instance directly if available
                    else if (window.markdownEditor.instance && typeof window.markdownEditor.instance.refresh === 'function') {
                        window.markdownEditor.instance.refresh();
                    }
                    // Otherwise just log a message
                    else {
                        console.log('[Markdown] No refresh method available for editor');
                    }
                }
                
                console.log('[Markdown] View mode updated to:', mode);
            } catch (error) {
                console.error('[Markdown] Error setting view mode:', error);
            }
        }
        
        // Function to save the markdown file (placeholder - would need to be implemented with actual file saving)
        function saveMarkdownFile() {
            if (!currentMarkdownFile || !window.markdownEditor) return;
            
            try {
                const content = window.markdownEditor.getValue();
                console.log('[Markdown] Would save file:', currentMarkdownFile.name);
                
                // In a real implementation, this would save to a file
                // For now, just update the current content
                currentMarkdownFile.content = content;
                
                // Show a temporary success message
                const statusIndicator = document.createElement('div');
                statusIndicator.className = 'markdown-save-status';
                statusIndicator.innerHTML = '<i class="fas fa-check"></i> Saved';
                document.body.appendChild(statusIndicator);
                
                // Remove the message after a delay
                setTimeout(() => {
                    statusIndicator.remove();
                }, 2000);
            } catch (error) {
                console.error('[Markdown] Error saving file:', error);
            }
        }
        
        // Initialize markdown view controls
        document.addEventListener('DOMContentLoaded', function() {
            console.log('[Markdown] Initializing markdown controls');
            
            // Add click handlers for view mode buttons
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.getAttribute('data-mode');
                    setMarkdownViewMode(mode);
                });
            });
        });
        
        // Function to handle loading a markdown file when selected in the file tree
        function handleMarkdownFileSelection(item) {
            console.log(`[Markdown] Handling markdown file selection: ${item ? item.name : 'unknown'}`);
            
            if (!item) {
                console.error('[Markdown] No item provided to markdown handler');
                return false;
            }
            
            // Ensure markdown functions are available before proceeding
            try {
                if (typeof ensureMarkdownFunctionsAvailable === 'function') {
                    ensureMarkdownFunctionsAvailable();
                } else {
                    console.warn('[Markdown] ensureMarkdownFunctionsAvailable function not available');
                }
            } catch (error) {
                console.error('[Markdown] Error ensuring functions available:', error);
            }
            
            // Ensure markdown section is visible using our new helper
            try {
                if (typeof window.ensureMarkdownSectionVisible === 'function') {
                    const containers = window.ensureMarkdownSectionVisible();
                    console.log('[Markdown] Container check result:', {
                        section: !!containers.markdownSection,
                        container: !!containers.markdownContainer,
                        editor: !!containers.markdownEditor,
                        preview: !!containers.markdownPreview
                    });
                    
                    // Initialize the view mode buttons if we have a section
                    if (containers.markdownSection) {
                        const viewModeButtons = containers.markdownSection.querySelectorAll('.view-mode-btn');
                        if (viewModeButtons.length) {
                            viewModeButtons.forEach(btn => {
                                btn.addEventListener('click', function() {
                                    const mode = this.getAttribute('data-mode');
                                    if (typeof setMarkdownViewMode === 'function') {
                                        setMarkdownViewMode(mode);
                                    } else {
                                        console.warn('[Markdown] setMarkdownViewMode function not available');
                                    }
                                });
                            });
                            console.log('[Markdown] View mode buttons initialized');
                        }
                    }
                } else {
                    // Show markdown section, hide PDF content (fallback if helper not available)
                    console.warn('[Markdown] ensureMarkdownSectionVisible function not available, using fallback');
                    const markdownSection = document.querySelector('.markdown-section');
                    const pdfContainer = document.getElementById('pdfPagesContainer');
                    
                    if (markdownSection) {
                        markdownSection.style.display = 'flex';
                        console.log('[Markdown] Section display set using fallback');
                    } else {
                        console.error('[Markdown] Markdown section not found using fallback');
                    }
                    
                    if (pdfContainer) {
                        pdfContainer.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('[Markdown] Error in section visibility handling:', error);
            }
            
            // Update markdown title
            try {
                const markdownTitle = document.getElementById('markdownTitle');
                if (markdownTitle) {
                    markdownTitle.textContent = item.name;
                }
            } catch (error) {
                console.error('[Markdown] Error updating title:', error);
            }
            
            // Get file content and load it
            try {
                if (item.file) {
                    console.log('[Markdown] Loading from file object');
                    if (typeof window.loadMarkdownFromFile === 'function') {
                        window.loadMarkdownFromFile(item.file);
                    } else {
                        console.error('[Markdown] loadMarkdownFromFile function not available');
                        // Direct fallback
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            if (typeof window.createMarkdownContent === 'function') {
                                window.createMarkdownContent(e.target.result, item.name);
                            } else {
                                console.error('[Markdown] All markdown functions unavailable');
                                alert('Error: Markdown functions not available');
                            }
                        };
                        reader.onerror = function(e) {
                            console.error('[Markdown] Error reading file:', e);
                            alert('Error reading file: ' + (e.message || 'Unknown error'));
                        };
                        reader.readAsText(item.file);
                    }
                } else if (item.fileHandle) {
                    // For File System Access API
                    console.log('[Markdown] Loading from file handle');
                    item.fileHandle.getFile().then(file => {
                        if (typeof window.loadMarkdownFromFile === 'function') {
                            window.loadMarkdownFromFile(file);
                        } else {
                            console.error('[Markdown] loadMarkdownFromFile function not available for handle');
                            // Similar direct fallback as above
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                if (typeof window.createMarkdownContent === 'function') {
                                    window.createMarkdownContent(e.target.result, item.name);
                                }
                            };
                            reader.readAsText(file);
                        }
                    }).catch(error => {
                        console.error('[Markdown] Error getting file from handle:', error);
                        const markdownPreview = document.getElementById('markdownPreview');
                        if (markdownPreview) {
                            markdownPreview.innerHTML = `<div class="markdown-error">Error: ${error.message}</div>`;
                        }
                    });
                } else {
                    console.error('[Markdown] No file reference available');
                    const markdownPreview = document.getElementById('markdownPreview');
                    if (markdownPreview) {
                        markdownPreview.innerHTML = '<div class="markdown-error">Error: No file reference available</div>';
                    }
                }
            } catch (error) {
                console.error('[Markdown] Error in file handling:', error);
            }
            
            return true;
        }
        
        // Make functions globally available
        window.handleMarkdownFileSelection = handleMarkdownFileSelection;
        window.updateMarkdownPreview = updateMarkdownPreview;
        window.setMarkdownViewMode = setMarkdownViewMode;
        window.saveMarkdownFile = saveMarkdownFile;
    </script>
    <!-- Markdown Functions -->
    <script>
        // Make all markdown functions globally available immediately
        function exposeMarkdownFunctions() {
            console.log('[Markdown] Exposing markdown functions globally');
            
            // Functions that should be globally available
            if (typeof loadMarkdown === 'function') window.loadMarkdown = loadMarkdown;
            if (typeof loadMarkdownFromFile === 'function') window.loadMarkdownFromFile = loadMarkdownFromFile;
            if (typeof updateMarkdownPreview === 'function') window.updateMarkdownPreview = updateMarkdownPreview;
            if (typeof setMarkdownViewMode === 'function') window.setMarkdownViewMode = setMarkdownViewMode;
            if (typeof saveMarkdownFile === 'function') window.saveMarkdownFile = saveMarkdownFile;
            if (typeof handleMarkdownFileSelection === 'function') window.handleMarkdownFileSelection = handleMarkdownFileSelection;
            if (typeof ensureMarkdownFunctionsAvailable === 'function') window.ensureMarkdownFunctionsAvailable = ensureMarkdownFunctionsAvailable;
        }
        
        // Call this function at the end of all scripts
        document.addEventListener('DOMContentLoaded', exposeMarkdownFunctions);
        
        // Backup direct exposure of functions
        window.loadMarkdown = window.loadMarkdown || loadMarkdown;
        window.loadMarkdownFromFile = window.loadMarkdownFromFile || loadMarkdownFromFile;
        window.updateMarkdownPreview = window.updateMarkdownPreview || updateMarkdownPreview;
        window.setMarkdownViewMode = window.setMarkdownViewMode || setMarkdownViewMode;
        window.saveMarkdownFile = window.saveMarkdownFile || saveMarkdownFile;
        window.handleMarkdownFileSelection = window.handleMarkdownFileSelection || handleMarkdownFileSelection;
        window.ensureMarkdownFunctionsAvailable = window.ensureMarkdownFunctionsAvailable || ensureMarkdownFunctionsAvailable;
        
        // Call expose function directly as a safeguard
        if (typeof exposeMarkdownFunctions === 'function') {
            exposeMarkdownFunctions();
        }
    </script>
    <!-- Direct fallback for initializing markdown content -->
    <script>
        // Direct function to create markdown content with fallbacks
        window.createMarkdownContent = function(content, fileName) {
            console.log('[Markdown] Creating markdown content for:', fileName);
            
            // First ensure the section is visible
            if (typeof window.ensureMarkdownSectionVisible === 'function') {
                const containers = window.ensureMarkdownSectionVisible();
                
                // Set the title
                const titleElement = document.getElementById('markdownTitle');
                if (titleElement) {
                    titleElement.textContent = fileName || 'Markdown Viewer';
                }
                
                // Get the elements directly
                const editorElement = document.getElementById('markdownEditor');
                const previewElement = document.getElementById('markdownPreview');
                
                if (!editorElement || !previewElement) {
                    console.error('[Markdown] Editor or preview element still not found after container creation');
                    // Create fallback display
                    const container = document.querySelector('.markdown-section');
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 20px; text-align: center;">
                                <h3>Fallback Markdown Display</h3>
                                <p>Editor containers could not be created.</p>
                                <pre style="text-align: left; background: #f5f5f5; padding: 10px; border-radius: 5px; max-height: 400px; overflow: auto;">${content ? content.replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'No content available'}</pre>
                            </div>
                        `;
                    }
                    return false;
                }
                
                // Reset the markdownEditor if it's not a proper CodeMirror instance
                if (window.markdownEditor && (!window.markdownEditor.setValue || !window.markdownEditor.getValue || !window.markdownEditor.refresh)) {
                    console.log('[Markdown] Resetting invalid CodeMirror instance');
                    window.markdownEditor = null;
                }
                
                try {
                    // SIMPLE TEXT DISPLAY FIRST - to ensure content is visible no matter what
                    console.log('[Markdown] Setting up direct text display first');
                    
                    // Simple editor display - with explicit styles
                    editorElement.innerHTML = `<textarea id="markdownTextarea" style="width:100%;height:100%;min-height:300px;border:1px solid #ddd;padding:10px;font-family:monospace;resize:none;outline:none;background-color:white;color:#333;font-size:14px;line-height:1.5;">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>`;
                    
                    // Simple preview display with more explicit styles
                    if (typeof marked !== 'undefined') {
                        previewElement.innerHTML = `<div class="marked-content" style="padding:20px;height:100%;overflow:auto;">${marked.parse(content)}</div>`;
                        // Apply syntax highlighting if Prism is available
                        if (typeof Prism !== 'undefined') {
                            Prism.highlightAllUnder(previewElement);
                        }
                    } else {
                        previewElement.innerHTML = `<pre style="white-space:pre-wrap;word-break:break-all;padding:20px;height:100%;overflow:auto;margin:0;font-family:monospace;font-size:14px;line-height:1.5;">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                    }
                    
                    // Force element dimensions to ensure visibility
                    const splitView = document.querySelector('.markdown-split-view');
                    if (splitView) {
                        splitView.style.display = 'flex';
                        splitView.style.flexDirection = 'row';
                        splitView.style.width = '100%';
                        splitView.style.height = '100%';
                        splitView.style.overflow = 'hidden';
                        
                        // Ensure editor is visible
                        if (editorElement) {
                            editorElement.style.display = 'block';
                            editorElement.style.flex = '1 0 50%';
                            editorElement.style.height = '100%';
                            editorElement.style.overflow = 'auto';
                        }
                        
                        // Ensure preview is visible
                        if (previewElement) {
                            previewElement.style.display = 'block';
                            previewElement.style.flex = '1 0 50%';
                            previewElement.style.height = '100%';
                            previewElement.style.overflow = 'auto';
                        }
                    }
                    
                    // Try to add basic textarea change handler
                    const textarea = document.getElementById('markdownTextarea');
                    if (textarea) {
                        textarea.addEventListener('input', function() {
                            try {
                                if (typeof marked !== 'undefined' && previewElement) {
                                    previewElement.innerHTML = marked.parse(textarea.value);
                                    // Apply syntax highlighting if Prism is available
                                    if (typeof Prism !== 'undefined') {
                                        Prism.highlightAllUnder(previewElement);
                                    }
                                }
                            } catch (error) {
                                console.error('[Markdown] Error updating preview from textarea:', error);
                            }
                        });
                    }
                    
                    // At this point, basic content should be visible
                    console.log('[Markdown] Direct text display complete');
                    
                    // Now try to initialize CodeMirror if available
                    if (typeof CodeMirror !== 'undefined') {
                        try {
                            console.log('[Markdown] Attempting to initialize CodeMirror');
                            
                            // Create a new textarea for CodeMirror to use
                            const cmTextarea = document.createElement('textarea');
                            cmTextarea.value = content;
                            cmTextarea.style.width = '100%';
                            cmTextarea.style.height = '100%';
                            cmTextarea.style.minHeight = '300px';
                            editorElement.innerHTML = '';
                            editorElement.appendChild(cmTextarea);
                            
                            // Initialize CodeMirror on the new textarea
                            const cmInstance = CodeMirror.fromTextArea(cmTextarea, {
                                mode: 'markdown',
                                lineNumbers: true,
                                lineWrapping: true,
                                theme: 'default',
                                viewportMargin: Infinity, // Render all content
                                autofocus: true
                            });
                            
                            // Add direct styles to CodeMirror
                            const cmElement = cmInstance.getWrapperElement();
                            cmElement.style.height = '100%';
                            cmElement.style.fontSize = '14px';
                            cmElement.style.lineHeight = '1.5';
                            cmElement.style.border = '1px solid #ddd';
                            cmElement.style.borderRadius = '4px';
                            
                            // Force refresh for proper sizing
                            setTimeout(() => {
                                cmInstance.refresh();
                            }, 10);
                            
                            // Add handler for content changes
                            cmInstance.on('change', function() {
                                try {
                                    const content = cmInstance.getValue();
                                    if (typeof marked !== 'undefined' && previewElement) {
                                        previewElement.innerHTML = marked.parse(content);
                                        if (typeof Prism !== 'undefined') {
                                            Prism.highlightAllUnder(previewElement);
                                        }
                                    }
                                } catch (error) {
                                    console.error('[Markdown] Error updating preview from CodeMirror:', error);
                                }
                            });
                            
                            // Store the instance with direct references to important methods
                            window.markdownEditor = {
                                instance: cmInstance,
                                getValue: function() { return cmInstance.getValue(); },
                                setValue: function(value) { return cmInstance.setValue(value); },
                                refresh: function() { return cmInstance.refresh(); }
                            };
                            
                            console.log('[Markdown] CodeMirror initialized successfully');
                        } catch (error) {
                            console.error('[Markdown] Error initializing CodeMirror, using simple textarea:', error);
                            // We already have a simple textarea set up, so we can continue
                        }
                    } else {
                        console.warn('[Markdown] CodeMirror not available, using simple textarea');
                    }
                } catch (error) {
                    console.error('[Markdown] Error in content creation:', error);
                    editorElement.innerHTML = `<div style="color:red;padding:10px;">Error: ${error.message}</div><textarea style="width:100%;height:100%;min-height:300px;">${content}</textarea>`;
                    previewElement.innerHTML = `<div style="color:red;padding:10px;">Error: ${error.message}</div><pre>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                }
                
                console.log('[Markdown] Content creation complete');
                return true;
            } else {
                console.error('[Markdown] ensureMarkdownSectionVisible function not available');
                return false;
            }
        };
    </script>
    <script>
        // Set up PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            console.log('[PDF.js] Worker initialized');
        } else {
            console.error('[PDF.js] PDF.js library not loaded');
        }
        
        // Check markdown libraries on page load
        window.addEventListener('DOMContentLoaded', function() {
            console.log('[Markdown] Checking libraries on page load');
            if (typeof marked === 'undefined') {
                console.error('[Markdown] Marked library not loaded');
            }
            if (typeof CodeMirror === 'undefined') {
                console.error('[Markdown] CodeMirror not loaded');
            }
            if (typeof Prism === 'undefined') {
                console.error('[Markdown] Prism not loaded');
            }
            
            // Ensure the markdown handler function is set globally
            // This addresses the error: "[FileTree] Markdown handler function not available"
            if (typeof handleMarkdownFileSelection === 'function') {
                window.handleMarkdownFileSelection = handleMarkdownFileSelection;
                console.log('[Markdown] Handler function set globally');
            } else {
                console.error('[Markdown] Handler function not available to set globally');
            }
        });
    </script>
    
    <!-- Direct standalone markdown viewer
    <script>
        // Function to create a completely standalone markdown viewer
        window.createStandaloneMarkdownViewer = function(content, fileName) {
            console.log('[Markdown] Creating standalone viewer for:', fileName);
            
            // Target the main content area
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) {
                console.error('[Markdown] Main content area not found');
                return false;
            }
            
            // Hide the PDF viewer
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                pdfViewer.style.display = 'none';
            }
            
            // Remove any existing markdown viewer
            const existingViewer = document.getElementById('standaloneMarkdownViewer');
            if (existingViewer) {
                existingViewer.remove();
            }
            
            // Create our standalone viewer
            const viewer = document.createElement('div');
            viewer.id = 'standaloneMarkdownViewer';
            viewer.style.position = 'absolute';
            viewer.style.top = '0';
            viewer.style.left = '0';
            viewer.style.width = '100%';
            viewer.style.height = '100%';
            viewer.style.backgroundColor = 'white';
            viewer.style.zIndex = '10';
            viewer.style.display = 'flex';
            viewer.style.flexDirection = 'column';
            viewer.style.overflow = 'hidden';
            
            // Add a header
            const header = document.createElement('div');
            header.style.backgroundColor = '#f5f5f5';
            header.style.borderBottom = '1px solid #ddd';
            header.style.padding = '8px 16px';
            header.style.display = 'flex';
            header.style.alignItems = 'center';
            header.style.justifyContent = 'space-between';
            header.style.height = '40px';
            
            // Add title
            const title = document.createElement('div');
            title.textContent = fileName || 'Markdown Viewer';
            title.style.fontWeight = 'bold';
            title.style.overflow = 'hidden';
            title.style.textOverflow = 'ellipsis';
            title.style.whiteSpace = 'nowrap';
            header.appendChild(title);
            
            // Add view mode controls
            const viewControls = document.createElement('div');
            viewControls.style.display = 'flex';
            viewControls.style.gap = '8px';
            
            const modes = [
                { name: 'Edit', value: 'edit' },
                { name: 'Split', value: 'split' },
                { name: 'Preview', value: 'preview' }
            ];
            
            modes.forEach(mode => {
                const btn = document.createElement('button');
                btn.textContent = mode.name;
                btn.setAttribute('data-mode', mode.value);
                btn.style.padding = '4px 8px';
                btn.style.border = 'none';
                btn.style.borderRadius = '4px';
                btn.style.cursor = 'pointer';
                btn.style.backgroundColor = mode.value === 'split' ? '#007bff' : 'transparent';
                btn.style.color = mode.value === 'split' ? 'white' : '#333';
                
                btn.addEventListener('click', function() {
                    // Update active button
                    viewControls.querySelectorAll('button').forEach(b => {
                        b.style.backgroundColor = 'transparent';
                        b.style.color = '#333';
                    });
                    btn.style.backgroundColor = '#007bff';
                    btn.style.color = 'white';
                    
                    // Apply view mode
                    const contentSection = document.getElementById('markdownContent');
                    if (contentSection) {
                        switch (mode.value) {
                            case 'edit':
                                contentSection.style.gridTemplateColumns = '1fr';
                                document.getElementById('markdownEditor').style.display = 'block';
                                document.getElementById('markdownPreview').style.display = 'none';
                                break;
                            case 'preview':
                                contentSection.style.gridTemplateColumns = '1fr';
                                document.getElementById('markdownEditor').style.display = 'none';
                                document.getElementById('markdownPreview').style.display = 'block';
                                break;
                            case 'split':
                                contentSection.style.gridTemplateColumns = '1fr 1fr';
                                document.getElementById('markdownEditor').style.display = 'block';
                                document.getElementById('markdownPreview').style.display = 'block';
                                break;
                        }
                    }
                });
                
                viewControls.appendChild(btn);
            });
            
            header.appendChild(viewControls);
            viewer.appendChild(header);
            
            // Create content section
            const contentSection = document.createElement('div');
            contentSection.id = 'markdownContent';
            contentSection.style.display = 'grid';
            contentSection.style.gridTemplateColumns = '1fr 1fr';
            contentSection.style.gap = '16px';
            contentSection.style.padding = '16px';
            contentSection.style.height = 'calc(100% - 40px)';
            contentSection.style.overflow = 'hidden';
            viewer.appendChild(contentSection);
            
            // Add editor
            const editor = document.createElement('div');
            editor.id = 'markdownEditor';
            editor.style.height = '100%';
            editor.style.overflow = 'auto';
            editor.style.border = '1px solid #ddd';
            editor.style.borderRadius = '4px';
            editor.style.backgroundColor = 'white';
            contentSection.appendChild(editor);
            
            // Add preview
            const preview = document.createElement('div');
            preview.id = 'markdownPreview';
            preview.style.height = '100%';
            preview.style.overflow = 'auto';
            preview.style.border = '1px solid #ddd';
            preview.style.borderRadius = '4px';
            preview.style.backgroundColor = 'white';
            preview.style.padding = '16px';
            contentSection.appendChild(preview);
            
            // Add the viewer to the main content
            mainContent.appendChild(viewer);
            
            try {
                // Create a simple textarea first
                const textarea = document.createElement('textarea');
                textarea.id = 'markdownTextarea';
                textarea.value = content;
                textarea.style.width = '100%';
                textarea.style.height = '100%';
                textarea.style.padding = '16px';
                textarea.style.border = 'none';
                textarea.style.resize = 'none';
                textarea.style.outline = 'none';
                textarea.style.fontFamily = 'monospace';
                textarea.style.fontSize = '14px';
                textarea.style.backgroundColor = bgPrimary;
                textarea.style.color = textPrimary;
                editor.appendChild(textarea);
                
                // Render preview
                if (typeof marked !== 'undefined') {
                    const renderedContent = marked.parse(content);
                    preview.innerHTML = `
                        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; line-height: 1.6; color: ${textPrimary};">
                            ${renderedContent}
                        </div>
                    `;
                    
                    // Apply syntax highlighting
                    if (typeof Prism !== 'undefined') {
                        Prism.highlightAllUnder(preview);
                    }
                    
                    // Fix list indentation (apply immediately)
                    fixListIndentation(preview);
                    
                    // Additional styling for lists and nested content
                    const styleElement = document.createElement('style');
                    styleElement.textContent = `
                        /* Enhanced list styling */
                        #markdownPreview ul, #markdownPreview ol {
                            padding-left: 20px;
                            margin-left: 0;
                        }
                        
                        #markdownPreview ul ul, #markdownPreview ol ol,
                        #markdownPreview ul ol, #markdownPreview ol ul {
                            margin-left: 20px;
                        }
                        
                        #markdownPreview li {
                            margin-bottom: 5px;
                        }
                        
                        /* Enhanced blockquote styling */
                        #markdownPreview blockquote {
                            margin-left: 0;
                            padding-left: 1em;
                            border-left: 0.25em solid ${borderColor};
                            color: ${textSecondary};
                        }
                        
                        /* Enhanced code styling */
                        #markdownPreview pre {
                            background-color: ${bgSecondary};
                            padding: 16px;
                            border-radius: 4px;
                            overflow: auto;
                        }
                        
                        #markdownPreview code {
                            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
                            font-size: 85%;
                        }
                        
                        #markdownPreview p code, 
                        #markdownPreview li code, 
                        #markdownPreview h1 code, 
                        #markdownPreview h2 code, 
                        #markdownPreview h3 code, 
                        #markdownPreview h4 code, 
                        #markdownPreview h5 code, 
                        #markdownPreview h6 code {
                            background-color: ${bgSecondary};
                            padding: 0.2em 0.4em;
                            border-radius: 3px;
                        }
                        
                        /* Enhanced table styling */
                        #markdownPreview table {
                            border-collapse: collapse;
                            width: 100%;
                            margin-bottom: 16px;
                        }
                        
                        #markdownPreview th, #markdownPreview td {
                            border: 1px solid ${borderColor};
                            padding: 6px 13px;
                        }
                        
                        #markdownPreview th {
                            background-color: ${bgSecondary};
                            font-weight: 600;
                        }
                    `;
                    document.head.appendChild(styleElement);
                    
                    // Add some basic styling to common elements
                    preview.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(el => {
                        el.style.borderBottom = '1px solid #eaecef';
                        el.style.paddingBottom = '0.3em';
                        el.style.marginTop = '24px';
                        el.style.marginBottom = '16px';
                        el.style.fontWeight = '600';
                        el.style.lineHeight = '1.25';
                    });
                    
                    preview.querySelectorAll('pre').forEach(el => {
                        el.style.padding = '16px';
                        el.style.overflow = 'auto';
                        el.style.backgroundColor = '#f6f8fa';
                        el.style.borderRadius = '3px';
                        el.style.marginBottom = '16px';
                    });
                    
                    preview.querySelectorAll('code').forEach(el => {
                        if (!el.closest('pre')) {
                            el.style.padding = '0.2em 0.4em';
                            el.style.margin = '0';
                            el.style.fontSize = '85%';
                            el.style.backgroundColor = 'rgba(27,31,35,0.05)';
                            el.style.borderRadius = '3px';
                        }
                    });
                    
                    preview.querySelectorAll('table').forEach(el => {
                        el.style.borderCollapse = 'collapse';
                        el.style.marginBottom = '16px';
                        el.style.display = 'block';
                        el.style.width = '100%';
                        el.style.overflow = 'auto';
                    });
                    
                    preview.querySelectorAll('th, td').forEach(el => {
                        el.style.padding = '6px 13px';
                        el.style.border = `1px solid ${borderColor}`;
                    });
                    
                    // Style blockquotes
                    preview.querySelectorAll('blockquote').forEach(el => {
                        el.style.padding = '0 1em';
                        el.style.borderLeft = `0.25em solid ${borderColor}`;
                        el.style.color = textSecondary;
                    });
                    
                    // Style links
                    preview.querySelectorAll('a').forEach(el => {
                        el.style.color = accentPrimary;
                        el.style.textDecoration = 'none';
                    });
                } else {
                    preview.innerHTML = `<pre style="padding: 16px; white-space: pre-wrap; word-break: break-word; color: ${textPrimary};">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                }
                
                // Set up live update
                textarea.addEventListener('input', function() {
                    if (typeof marked !== 'undefined') {
                        const renderedContent = marked.parse(textarea.value);
                        preview.innerHTML = `
                            <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; line-height: 1.6; color: ${textPrimary};">
                                ${renderedContent}
                            </div>
                        `;
                        
                        // Apply syntax highlighting
                        if (typeof Prism !== 'undefined') {
                            Prism.highlightAllUnder(preview);
                        }
                    } else {
                        preview.innerHTML = `<pre style="padding: 16px; white-space: pre-wrap; word-break: break-word; color: ${textPrimary};">${textarea.value.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                    }
                });
                
                // Try to initialize CodeMirror if available
                if (typeof CodeMirror !== 'undefined') {
                    try {
                        const cm = CodeMirror.fromTextArea(textarea, {
                            mode: 'markdown',
                            lineNumbers: true,
                            lineWrapping: true,
                            theme: 'default',
                            viewportMargin: Infinity
                        });
                        
                        // Style the CodeMirror instance
                        const cmElement = cm.getWrapperElement();
                        cmElement.style.height = '100%';
                        cmElement.style.fontSize = '14px';
                        cmElement.style.backgroundColor = bgPrimary;
                        
                        // Improve code styling
                        const styleElement = document.createElement('style');
                        styleElement.textContent = `
                            /* Basic text color */
                            .CodeMirror pre.CodeMirror-line, 
                            .CodeMirror pre.CodeMirror-line-like {
                                color: ${textPrimary};
                            }
                            
                            /* Style markdown syntax elements with a light blue color */
                            .cm-header, .cm-quote, .cm-link, .cm-url,
                            .cm-string, .cm-comment, .cm-list, .cm-meta,
                            .cm-variable, .cm-variable-2, .cm-hr, .cm-keyword,
                            .cm-attribute, .cm-tag, .cm-def {
                                color: #7bc5ff !important;
                            }
                            
                            /* Style text content */
                            .cm-string-2, .cm-qualifier, .cm-property, .cm-em,
                            .cm-strong, .cm-atom, .cm-number, .cm-variable-3,
                            .cm-builtin, .cm-bracket, .cm-operator, .cm-punctuation {
                                color: ${textPrimary} !important;
                            }
                            
                            /* Style active line */
                            .CodeMirror-activeline-background {
                                background: rgba(128, 128, 128, 0.1);
                            }
                            
                            /* Style selected text */
                            .CodeMirror-selected {
                                background: rgba(128, 128, 255, 0.1) !important;
                            }
                        `;
                        document.head.appendChild(styleElement);
                        
                        // Try to style the CodeMirror content
                        const cmContent = cmElement.querySelector('.CodeMirror-sizer');
                        if (cmContent) {
                            cmContent.style.color = textPrimary;
                        }
                        
                        // Update preview on change
                        cm.on('change', function() {
                            if (typeof marked !== 'undefined') {
                                const renderedContent = marked.parse(cm.getValue());
                                const formattedContent = `
                                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; line-height: 1.6; color: ${textPrimary};">
                                        ${renderedContent}
                                    </div>
                                `;
                                preview.innerHTML = formattedContent;
                                
                                // Apply syntax highlighting
                                if (typeof Prism !== 'undefined') {
                                    Prism.highlightAllUnder(preview);
                                }
                                
                                // Fix list indentation
                                fixListIndentation(preview);
                            }
                        });
                        
                        // Initial preview rendering with fixed indentation
                        if (typeof marked !== 'undefined') {
                            setTimeout(() => {
                                fixListIndentation(preview);
                            }, 100);
                        }
                    } catch (error) {
                        console.error('[Markdown] Error initializing CodeMirror:', error);
                    }
                }
                
                // Helper function to fix list indentation
                function fixListIndentation(previewElement) {
                    // Fix nested lists indentation
                    const lists = previewElement.querySelectorAll('ul, ol');
                    lists.forEach(list => {
                        // Make sure list items have proper indentation
                        list.style.paddingLeft = '20px';
                        list.style.marginLeft = '0';
                        
                        // Fix nested lists
                        const nestedLists = list.querySelectorAll('ul, ol');
                        nestedLists.forEach(nestedList => {
                            nestedList.style.marginLeft = '20px';
                        });
                        
                        // Ensure list items have proper styling
                        const listItems = list.querySelectorAll('li');
                        listItems.forEach(item => {
                            item.style.marginBottom = '5px';
                        });
                    });
                    
                    // Fix blockquote indentation
                    const blockquotes = previewElement.querySelectorAll('blockquote');
                    blockquotes.forEach(quote => {
                        quote.style.marginLeft = '0';
                        quote.style.paddingLeft = '1em';
                        quote.style.borderLeft = `0.25em solid ${borderColor}`;
                    });
                    
                    // Fix code block indentation
                    const codeBlocks = previewElement.querySelectorAll('pre');
                    codeBlocks.forEach(block => {
                        block.style.marginLeft = '0';
                    });
                }
                
                // Apply initial fixes to preview
                fixListIndentation(preview);
                
                console.log('[Markdown] Standalone viewer created successfully');
                return true;
            } catch (error) {
                console.error('[Markdown] Error creating standalone viewer:', error);
                return false;
            }
        };
    </script>
    
    <!-- Update the file handling to use our standalone viewer -->
    <script>
        // Update handleMarkdownFileSelection to use the standalone viewer
        const originalHandleMarkdownFileSelection = window.handleMarkdownFileSelection;
        
        window.handleMarkdownFileSelection = function(item) {
            console.log('[Markdown] Using standalone viewer for', item.name);
            
            if (!item) {
                console.error('[Markdown] No item provided to markdown handler');
                return false;
            }
            
            try {
                if (item.file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        window.createStandaloneMarkdownViewer(e.target.result, item.name);
                    };
                    reader.onerror = function(e) {
                        console.error('[Markdown] Error reading file:', e);
                        alert('Error reading file: ' + (e.message || 'Unknown error'));
                    };
                    reader.readAsText(item.file);
                    return true;
                } else if (item.fileHandle) {
                    item.fileHandle.getFile().then(file => {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            window.createStandaloneMarkdownViewer(e.target.result, item.name);
                        };
                        reader.readAsText(file);
                    }).catch(error => {
                        console.error('[Markdown] Error getting file from handle:', error);
                    });
                    return true;
                } else {
                    console.error('[Markdown] No file reference available');
                    return false;
                }
            } catch (error) {
                console.error('[Markdown] Error in standalone file handling:', error);
                
                // Try to fall back to the original handler if it exists
                if (typeof originalHandleMarkdownFileSelection === 'function') {
                    console.log('[Markdown] Falling back to original handler');
                    return originalHandleMarkdownFileSelection(item);
                }
                
                return false;
            }
        };
    </script>
    <!-- Update PDF loading to hide markdown viewer -->
    <script>
        // Store reference to the original loadPDF function
        const originalLoadPDF = window.loadPDF;
        
        // Override loadPDF to also hide the markdown viewer
        window.loadPDF = function(url, name, scrollToPage, setCurrentPage) {
            console.log('[PDF] Loading PDF and hiding markdown viewer');
            
            // Hide the markdown viewer if it exists
            const markdownViewer = document.getElementById('standaloneMarkdownViewer');
            if (markdownViewer) {
                markdownViewer.style.display = 'none';
            }
            
            // Show the PDF viewer
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                pdfViewer.style.display = 'block';
            }
            
            // Call the original function
            return originalLoadPDF(url, name, scrollToPage, setCurrentPage);
        };
    </script>
    <!-- Improved standalone markdown viewer with consistent styling -->
    <script>
        // Function to create a completely standalone markdown viewer
        window.createStandaloneMarkdownViewer = function(content, fileName) {
            console.log('[Markdown] Creating standalone viewer for:', fileName);
            
            // Target the main content area
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) {
                console.error('[Markdown] Main content area not found');
                return false;
            }
            
            // Hide the PDF viewer
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                pdfViewer.style.display = 'none';
            }
            
            // Remove any existing markdown viewer
            const existingViewer = document.getElementById('standaloneMarkdownViewer');
            if (existingViewer) {
                existingViewer.remove();
            }
            
            // Get application colors and styles
            const computedStyle = getComputedStyle(document.documentElement);
            const bgPrimary = computedStyle.getPropertyValue('--bg-primary') || 'white';
            const bgSecondary = computedStyle.getPropertyValue('--bg-secondary') || '#f5f5f5';
            const textPrimary = computedStyle.getPropertyValue('--text-primary') || '#333';
            const textSecondary = computedStyle.getPropertyValue('--text-secondary') || '#666';
            const accentPrimary = computedStyle.getPropertyValue('--accent-primary') || '#007bff';
            const borderColor = computedStyle.getPropertyValue('--border-color') || '#ddd';
            
            // Create our standalone viewer
            const viewer = document.createElement('div');
            viewer.id = 'standaloneMarkdownViewer';
            viewer.style.position = 'absolute';
            viewer.style.top = '0';
            viewer.style.left = '0';
            viewer.style.width = '100%';
            viewer.style.height = '100%';
            viewer.style.backgroundColor = bgPrimary;
            viewer.style.zIndex = '10';
            viewer.style.display = 'flex';
            viewer.style.flexDirection = 'column';
            viewer.style.overflow = 'hidden';
            
            // Add a header
            const header = document.createElement('div');
            header.style.backgroundColor = bgSecondary;
            header.style.borderBottom = `1px solid ${borderColor}`;
            header.style.padding = '8px 16px';
            header.style.display = 'flex';
            header.style.alignItems = 'center';
            header.style.justifyContent = 'space-between';
            header.style.height = '40px';
            
            // Add title
            const title = document.createElement('div');
            title.textContent = fileName || 'Markdown Viewer';
            title.style.fontWeight = 'bold';
            title.style.overflow = 'hidden';
            title.style.textOverflow = 'ellipsis';
            title.style.whiteSpace = 'nowrap';
            title.style.color = textPrimary;
            header.appendChild(title);
            
            // Add view mode controls
            const viewControls = document.createElement('div');
            viewControls.style.display = 'flex';
            viewControls.style.gap = '8px';
            
            const modes = [
                { name: 'Edit', value: 'edit' },
                { name: 'Split', value: 'split' },
                { name: 'Preview', value: 'preview' }
            ];
            
            modes.forEach(mode => {
                const btn = document.createElement('button');
                btn.textContent = mode.name;
                btn.setAttribute('data-mode', mode.value);
                btn.style.padding = '4px 8px';
                btn.style.border = 'none';
                btn.style.borderRadius = '4px';
                btn.style.cursor = 'pointer';
                btn.style.backgroundColor = mode.value === 'split' ? accentPrimary : 'transparent';
                btn.style.color = mode.value === 'split' ? 'white' : textSecondary;
                
                btn.addEventListener('click', function() {
                    // Update active button
                    viewControls.querySelectorAll('button').forEach(b => {
                        b.style.backgroundColor = 'transparent';
                        b.style.color = textSecondary;
                    });
                    btn.style.backgroundColor = accentPrimary;
                    btn.style.color = 'white';
                    
                    // Apply view mode
                    const contentSection = document.getElementById('markdownContent');
                    if (contentSection) {
                        switch (mode.value) {
                            case 'edit':
                                contentSection.style.gridTemplateColumns = '1fr';
                                document.getElementById('markdownEditor').style.display = 'block';
                                document.getElementById('markdownPreview').style.display = 'none';
                                break;
                            case 'preview':
                                contentSection.style.gridTemplateColumns = '1fr';
                                document.getElementById('markdownEditor').style.display = 'none';
                                document.getElementById('markdownPreview').style.display = 'block';
                                break;
                            case 'split':
                                contentSection.style.gridTemplateColumns = '1fr 1fr';
                                document.getElementById('markdownEditor').style.display = 'block';
                                document.getElementById('markdownPreview').style.display = 'block';
                                break;
                        }
                    }
                });
                
                viewControls.appendChild(btn);
            });
            
            header.appendChild(viewControls);
            viewer.appendChild(header);
            
            // Create content section
            const contentSection = document.createElement('div');
            contentSection.id = 'markdownContent';
            contentSection.style.display = 'grid';
            contentSection.style.gridTemplateColumns = '1fr 1fr';
            contentSection.style.gap = '16px';
            contentSection.style.padding = '16px';
            contentSection.style.height = 'calc(100% - 40px)';
            contentSection.style.overflow = 'hidden';
            contentSection.style.backgroundColor = bgPrimary;
            viewer.appendChild(contentSection);
            
            // Add editor
            const editor = document.createElement('div');
            editor.id = 'markdownEditor';
            editor.style.height = '100%';
            editor.style.overflow = 'auto';
            editor.style.border = `1px solid ${borderColor}`;
            editor.style.borderRadius = '4px';
            editor.style.backgroundColor = bgPrimary;
            contentSection.appendChild(editor);
            
            // Add preview
            const preview = document.createElement('div');
            preview.id = 'markdownPreview';
            preview.style.height = '100%';
            preview.style.overflow = 'auto';
            preview.style.border = `1px solid ${borderColor}`;
            preview.style.borderRadius = '4px';
            preview.style.backgroundColor = bgPrimary;
            preview.style.padding = '16px';
            preview.style.color = textPrimary;
            contentSection.appendChild(preview);
            
            // Add the viewer to the main content
            mainContent.appendChild(viewer);
            
            try {
                // Create a simple textarea first
                const textarea = document.createElement('textarea');
                textarea.id = 'markdownTextarea';
                textarea.value = content;
                textarea.style.width = '100%';
                textarea.style.height = '100%';
                textarea.style.padding = '16px';
                textarea.style.border = 'none';
                textarea.style.resize = 'none';
                textarea.style.outline = 'none';
                textarea.style.fontFamily = 'monospace';
                textarea.style.fontSize = '14px';
                textarea.style.lineHeight = '1.6';
                textarea.style.backgroundColor = bgPrimary;
                textarea.style.color = textPrimary;
                editor.appendChild(textarea);
                
                // Add textarea styles for markdown
                const textareaStyle = document.createElement('style');
                textareaStyle.textContent = `
                    #markdownTextarea {
                        tab-size: 4;
                        white-space: pre-wrap;
                        word-break: keep-all;
                        overflow-wrap: break-word;
                        caret-color: ${accentPrimary};
                    }
                    
                    #markdownTextarea:focus {
                        box-shadow: 0 0 0 2px ${accentPrimary}33;
                    }
                `;
                document.head.appendChild(textareaStyle);
                
                // Render preview
                if (typeof marked !== 'undefined') {
                    const renderedContent = marked.parse(content);
                    preview.innerHTML = `
                        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; line-height: 1.6; color: ${textPrimary};">
                            ${renderedContent}
                        </div>
                    `;
                    
                    // Apply syntax highlighting
                    if (typeof Prism !== 'undefined') {
                        Prism.highlightAllUnder(preview);
                    }
                    
                    // Fix list indentation (apply immediately)
                    fixListIndentation(preview);
                    
                    // Additional styling for lists and nested content
                    const styleElement = document.createElement('style');
                    styleElement.textContent = `
                        /* Enhanced list styling */
                        #markdownPreview ul, #markdownPreview ol {
                            padding-left: 20px;
                            margin-left: 0;
                        }
                        
                        #markdownPreview ul ul, #markdownPreview ol ol,
                        #markdownPreview ul ol, #markdownPreview ol ul {
                            margin-left: 20px;
                        }
                        
                        #markdownPreview li {
                            margin-bottom: 5px;
                        }
                        
                        /* Enhanced blockquote styling */
                        #markdownPreview blockquote {
                            margin-left: 0;
                            padding-left: 1em;
                            border-left: 0.25em solid ${borderColor};
                            color: ${textSecondary};
                        }
                        
                        /* Enhanced code styling */
                        #markdownPreview pre {
                            background-color: ${bgSecondary};
                            padding: 16px;
                            border-radius: 4px;
                            overflow: auto;
                        }
                        
                        #markdownPreview code {
                            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
                            font-size: 85%;
                        }
                        
                        #markdownPreview p code, 
                        #markdownPreview li code, 
                        #markdownPreview h1 code, 
                        #markdownPreview h2 code, 
                        #markdownPreview h3 code, 
                        #markdownPreview h4 code, 
                        #markdownPreview h5 code, 
                        #markdownPreview h6 code {
                            background-color: ${bgSecondary};
                            padding: 0.2em 0.4em;
                            border-radius: 3px;
                        }
                        
                        /* Enhanced table styling */
                        #markdownPreview table {
                            border-collapse: collapse;
                            width: 100%;
                            margin-bottom: 16px;
                        }
                        
                        #markdownPreview th, #markdownPreview td {
                            border: 1px solid ${borderColor};
                            padding: 6px 13px;
                        }
                        
                        #markdownPreview th {
                            background-color: ${bgSecondary};
                            font-weight: 600;
                        }
                    `;
                    document.head.appendChild(styleElement);
                    
                    // Add some basic styling to common elements
                    preview.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(el => {
                        el.style.borderBottom = '1px solid #eaecef';
                        el.style.paddingBottom = '0.3em';
                        el.style.marginTop = '24px';
                        el.style.marginBottom = '16px';
                        el.style.fontWeight = '600';
                        el.style.lineHeight = '1.25';
                    });
                    
                    preview.querySelectorAll('pre').forEach(el => {
                        el.style.padding = '16px';
                        el.style.overflow = 'auto';
                        el.style.backgroundColor = bgSecondary;
                        el.style.borderRadius = '3px';
                        el.style.marginBottom = '16px';
                    });
                    
                    preview.querySelectorAll('code').forEach(el => {
                        if (!el.closest('pre')) {
                            el.style.padding = '0.2em 0.4em';
                            el.style.margin = '0';
                            el.style.fontSize = '85%';
                            el.style.backgroundColor = bgSecondary;
                            el.style.borderRadius = '3px';
                        }
                    });
                    
                    preview.querySelectorAll('table').forEach(el => {
                        el.style.borderCollapse = 'collapse';
                        el.style.marginBottom = '16px';
                        el.style.display = 'block';
                        el.style.width = '100%';
                        el.style.overflow = 'auto';
                    });
                    
                    preview.querySelectorAll('th, td').forEach(el => {
                        el.style.padding = '6px 13px';
                        el.style.border = `1px solid ${borderColor}`;
                    });
                    
                    // Style blockquotes
                    preview.querySelectorAll('blockquote').forEach(el => {
                        el.style.padding = '0 1em';
                        el.style.borderLeft = `0.25em solid ${borderColor}`;
                        el.style.color = textSecondary;
                    });
                    
                    // Style links
                    preview.querySelectorAll('a').forEach(el => {
                        el.style.color = accentPrimary;
                        el.style.textDecoration = 'none';
                    });
                } else {
                    preview.innerHTML = `<pre style="padding: 16px; white-space: pre-wrap; word-break: break-word; color: ${textPrimary};">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                }
                
                // Set up live update
                textarea.addEventListener('input', function() {
                    if (typeof marked !== 'undefined') {
                        const renderedContent = marked.parse(textarea.value);
                        preview.innerHTML = `
                            <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; line-height: 1.6; color: ${textPrimary};">
                                ${renderedContent}
                            </div>
                        `;
                        
                        // Apply syntax highlighting
                        if (typeof Prism !== 'undefined') {
                            Prism.highlightAllUnder(preview);
                        }
                    } else {
                        preview.innerHTML = `<pre style="padding: 16px; white-space: pre-wrap; word-break: break-word; color: ${textPrimary};">${textarea.value.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
                    }
                });
                
                // Try to initialize CodeMirror if available
                if (typeof CodeMirror !== 'undefined') {
                    try {
                        const cm = CodeMirror.fromTextArea(textarea, {
                            mode: 'markdown',
                            lineNumbers: true,
                            lineWrapping: true,
                            theme: 'default',
                            viewportMargin: Infinity
                        });
                        
                        // Style the CodeMirror instance
                        const cmElement = cm.getWrapperElement();
                        cmElement.style.height = '100%';
                        cmElement.style.fontSize = '14px';
                        cmElement.style.backgroundColor = bgPrimary;
                        
                        // Improve code styling
                        const styleElement = document.createElement('style');
                        styleElement.textContent = `
                            /* Basic text color */
                            .CodeMirror pre.CodeMirror-line, 
                            .CodeMirror pre.CodeMirror-line-like {
                                color: ${textPrimary};
                            }
                            
                            /* Style markdown syntax elements with a light blue color */
                            .cm-header, .cm-quote, .cm-link, .cm-url,
                            .cm-string, .cm-comment, .cm-list, .cm-meta,
                            .cm-variable, .cm-variable-2, .cm-hr, .cm-keyword,
                            .cm-attribute, .cm-tag, .cm-def {
                                color: #7bc5ff !important;
                            }
                            
                            /* Style text content */
                            .cm-string-2, .cm-qualifier, .cm-property, .cm-em,
                            .cm-strong, .cm-atom, .cm-number, .cm-variable-3,
                            .cm-builtin, .cm-bracket, .cm-operator, .cm-punctuation {
                                color: ${textPrimary} !important;
                            }
                            
                            /* Style active line */
                            .CodeMirror-activeline-background {
                                background: rgba(128, 128, 128, 0.1);
                            }
                            
                            /* Style selected text */
                            .CodeMirror-selected {
                                background: rgba(128, 128, 255, 0.1) !important;
                            }
                        `;
                        document.head.appendChild(styleElement);
                        
                        // Try to style the CodeMirror content
                        const cmContent = cmElement.querySelector('.CodeMirror-sizer');
                        if (cmContent) {
                            cmContent.style.color = textPrimary;
                        }
                        
                        // Update preview on change
                        cm.on('change', function() {
                            if (typeof marked !== 'undefined') {
                                const renderedContent = marked.parse(cm.getValue());
                                const formattedContent = `
                                    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; line-height: 1.6; color: ${textPrimary};">
                                        ${renderedContent}
                                    </div>
                                `;
                                preview.innerHTML = formattedContent;
                                
                                // Apply syntax highlighting
                                if (typeof Prism !== 'undefined') {
                                    Prism.highlightAllUnder(preview);
                                }
                                
                                // Fix list indentation
                                fixListIndentation(preview);
                            }
                        });
                        
                        // Initial preview rendering with fixed indentation
                        if (typeof marked !== 'undefined') {
                            setTimeout(() => {
                                fixListIndentation(preview);
                            }, 100);
                        }
                    } catch (error) {
                        console.error('[Markdown] Error initializing CodeMirror:', error);
                    }
                }
                
                // Helper function to fix list indentation
                function fixListIndentation(previewElement) {
                    // Fix nested lists indentation
                    const lists = previewElement.querySelectorAll('ul, ol');
                    lists.forEach(list => {
                        // Make sure list items have proper indentation
                        list.style.paddingLeft = '20px';
                        list.style.marginLeft = '0';
                        
                        // Fix nested lists
                        const nestedLists = list.querySelectorAll('ul, ol');
                        nestedLists.forEach(nestedList => {
                            nestedList.style.marginLeft = '20px';
                        });
                        
                        // Ensure list items have proper styling
                        const listItems = list.querySelectorAll('li');
                        listItems.forEach(item => {
                            item.style.marginBottom = '5px';
                        });
                    });
                    
                    // Fix blockquote indentation
                    const blockquotes = previewElement.querySelectorAll('blockquote');
                    blockquotes.forEach(quote => {
                        quote.style.marginLeft = '0';
                        quote.style.paddingLeft = '1em';
                        quote.style.borderLeft = `0.25em solid ${borderColor}`;
                    });
                    
                    // Fix code block indentation
                    const codeBlocks = previewElement.querySelectorAll('pre');
                    codeBlocks.forEach(block => {
                        block.style.marginLeft = '0';
                    });
                }
                
                // Apply initial fixes to preview
                fixListIndentation(preview);
                
                console.log('[Markdown] Standalone viewer created successfully');
                return true;
            } catch (error) {
                console.error('[Markdown] Error creating standalone viewer:', error);
                return false;
            }
        };
    </script>
</body>
</html>